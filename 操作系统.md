　

# 对目录文件的读取，　写入

## ls

 文件属性(占10个字符空间)    文件数     拥有者    所属的group   文件大小    建档日期      文件名
　　

```c++
  drwx------               2       Guest       users       1024      Nov 21 21:05   Mail　　
  -rwx--x--x               1        root         root         89080     Nov 7 22:41    tar*　　
  -rwxr-xr-x               1        root         bin         5013      Aug 15 9:32     uname*　　
  lrwxrwxrwx              1        root         root         4         Nov 24 19:30    zcat->gzip　　
  -rwxr-xr-x               1        root         bin         308364    Nov 29 7:43     zsh*　　
  -rwsr-x---               1        root         bin         9853      Aug 15 5:46     su*
  -rw-r--r--                1        Hhf         197121      146        10月 18 17:37   main.m
```





-a：显示所有档案及目录（ls内定将档案名或目录名称为“.”的视为影藏，不会列出）；

-A：显示除影藏文件“.”和“..”以外的所有文件列表；

-C：多列显示输出结果。这是默认选项；

-l：与“-C”选项功能相反，所有输出信息用单列格式输出，不输出为多列；

-F：在每个输出项后追加文件的类型标识符，具体含义：“*”表示具有可执行权限的普通文件，“/”表示目录，“@”表示符号链接，“|”表示命令管道FIFO，“=”表示sockets套接字。当文件为普通文件时，不输出任何标识符；*

*-b：将文件中的不可输出的字符以反斜线“”加字符编码的方式输出；*

*-c：与“-lt”选项连用时，按照文件状态时间排序输出目录内容，排序的依据是文件的索引节点中的ctime字段。与“-l”选项连用时，则排序的一句是文件的状态改变时间；*

*-d：仅显示目录名，而不显示目录下的内容列表。显示符号链接文件本身，而不显示其所指向的目录列表；*

*-f：此参数的效果和同时指定“aU”参数相同，并关闭“lst”参数的效果；*

*-i：显示文件索引节点号（inode）。一个索引节点代表一个文件；*

*--file-type：与“-F”选项的功能相同，但是不显示“*”；-

k：以KB（千字节）为单位显示文件大小；

-l：以长格式显示目录下的内容列表。输出的信息从左到右依次包括文件名，文件类型、权限模式、硬连接数、所有者、组、文件大小和文件的最后修改时间等；-m：用“,”号区隔每个文件和目录的名称；

-n：以用户识别码和群组识别码替代其名称；

-r：以文件名反序排列并输出目录内容列表；

-s：显示文件和目录的大小，以区块为单位；

-t：用文件和目录的更改时间排序；

-L：如果遇到性质为符号链接的文件或目录，直接列出该链接所指向的原始文件或目录；-R：递归处理，将指定目录下的所有文件及子目录一并处理；

--full-time：列出完整的日期与时间；

--color[=WHEN]：使用不同的颜色高亮显示不同类型的。



```c++
#include "head.h"

#define MAXNAME 512
#define MAXFILE 1024

void do_ls(char *);
void show_info(char *, struct stat *);
void output(char *, struct stat *);
int l_flag = 0, a_flag = 0;

char *uid_to_name(uid_t uid);
char *gid_to_name(gid_t name);

int bg_c, fg_c;

int main(int argc, char **argv) {
    int opt;
    while ((opt = getopt(argc, argv, "la")) != -1) {
        switch (opt) {
            case 'l':
                l_flag = 1;
                break;
            case 'a':
                a_flag = 1;
                break;
            default:
                fprintf(stderr, "Usage : %s [-la]!\n", argv[0]);
                exit(1);
        }
    }
    DBG(GREEN"<Debug>"NONE": optind = %d\n", optind);
    DBG(GREEN"<Debug>"NONE" : l = %d, a = %d\n", l_flag, a_flag);
    DBG(GREEN"<Debug>"NONE" : argv[optind] = %s\n", argv[optind]);
    DBG(GREEN"<Debug>"NONE" : argv[optind - 1] = %s\n", argv[optind - 1]);
    DBG(GREEN"<Debug>"NONE" : argv[0] = %s\n", argv[0]);
    argc -= optind; //获取参数个数
    argv += optind;　//第一个参数的位置

    if (argc == 0) {//ls -a无参数, 此时的argc 是参数的个数
        do_ls(".");
        DBG(GREEN"<Debug>"NONE": Doing with .\n");
    } else {//ls -l -a a.c b.c
        while(argc--){
            do_ls(*(argv++));
            DBG(GREEN"<Debug>"NONE" : Doing with %s\n", *(argv - 1));
        }
    }
    
    return 0;
}

int cmp_name(const void* _a, const void* _b) {
    char *a = (char *)_a;
    char *b = (char *)_b;
    return strcmp(a, b);
}

void update_color(mode_t mode) {
    bg_c = 0;
    fg_c = 31;
    if (mode & (S_IXGRP | S_IXUSR | S_IXOTH)) {
        fg_c = 32;//若文件用户，群,其他人都可执行
    } //或if (mode & 0111);
    switch(mode & S_IFMT) {
        case S_IFDIR:
            fg_c = 34;
            break;
        case S_IFLNK:
            fg_c = 35;
            break;
    }
    return ;
}

void size_window(char names[][MAXNAME], int cnt, int *row, int *col) {
    struct winsize size;
    int len[cnt], max = 0, total_len = 0;
    memset(len, 0, sizeof(int) * cnt);
    if (ioctl(STDOUT_FILENO, TIOCGWINSZ, &size) < 0) {//获取窗口的大小,将当前窗口的信息存在结构体size中
        perror("ioctl()");
        exit(1);
    }
    DBG(GREEN"<Debug>"NONE" : win.row = %d, win.col = %d\n", size.ws_row, size.ws_col);
    for (int i = 0; i < cnt; i++) {
        len[i] = strlen(names[i]);
        if (max < len[i]) max = len[i];
        total_len += len[i] + 1;
    }
    if (max + 1 >= size.ws_col) {
        *row = cnt;
        *col = 1;
        return ;
    }
    if (total_len <= size.ws_col) {
        *row = 1;
        *col = cnt;
        return ;
    }
    int try_begin = 0;
    for (int i = 0, tmp = 0; i < cnt; i++) {//获取一行的文件数
        tmp += (len[i] + 1);//此时的长度
        if (tmp >= size.ws_col) {
            try_begin = i;
            break;
        }
    }

    for (int i = try_begin; ; i--) {
        int *wide = (int *)malloc(sizeof(int) * i);//每列的宽度
        memset(wide, 0, sizeof(int) * i);
        *row = (int)ceil(cnt * 1.0 / i);//上取整,得到行
        int sum = 0;
        for (int x = 0; x < i; x++) {//x是列
            for (int y = x * (*row); y < (x + 1) * (*row) && y < cnt; y++) {
                if (wide[x] < len[y]) wide[x] = len[y];//获取每列的宽度
            }
            sum += (wide[x] + 1);
        }
        if (sum > size.ws_col) continue;
        if (sum <= size.ws_col) {
            *col = i;
            break;
        }
    }
}

void show_files(char names[][MAXNAME], int cnt, int row, int col) {
    int wide[col];
    memset(wide, 0, sizeof(int) * col);
    struct stat tmp_st;
    for (int i = 0; i < col; i++) {
        for (int j = (i * row); j < (i + 1) * row && j < cnt; j++) {
            if (wide[i] < strlen(names[j])) wide[i] = strlen(names[j]);
        }
    }

    for (int i = 0; i < row; i++) {
        //for (int j = i; (j <= i + (row * col)) && j < cnt; j = j + row) {
        for (int j = i; (j < cnt); j += row) {
            lstat(names[j], &tmp_st);
            update_color(tmp_st.st_mode);
            int wide_tmp = wide[j / row];//每列的宽度
            printf("\033[%d;%dm%-*s \033[0m", bg_c, fg_c, wide_tmp, names[j]);
        }
        printf("\n");
    }
}

void do_ls(char *dir) {
    DIR *dirp = NULL;
    struct dirent *direntp;
    DBG(GREEN"<Debug>"NONE ": %s\n", dir);
    if ((dirp = opendir(dir)) == NULL) {//目录打开失败
        if (access(dir, R_OK) == 0) {//判断文件是否可读, 0可读，-1不可读
            if (l_flag == 1) {//-l输出非隐藏文件的信息
                struct stat tmp_st;
                lstat(dir, &tmp_st);
                show_info(dir, &tmp_st);
                printf("\n\n");
            } else {
                printf("%s\n", dir);//-a 输出包括隐藏的所有文件名
            }
        } else {
            perror(dir);
            exit(1);
        }
    } else {//是目录，遍历目录
        char names[MAXFILE][MAXNAME] = {0};
        printf("%s :\n", dir);
        int cnt = 0;
        while ((direntp = readdir(dirp)) != NULL) {
            if (direntp->d_name[0] == '.' && (a_flag == 0)) continue;
            strcpy(names[cnt++], direntp->d_name);
        }
        qsort(names, cnt, MAXNAME, cmp_name);
        chdir(dir);//跳转目录，改变路径
        if (l_flag == 1) {//-l
            for (int i = 0; i < cnt; i++) {
                struct stat st_tmp;
                lstat(names[i], &st_tmp);
                show_info(names[i], &st_tmp);
                printf("\n");
            }
        } else {//-a
            int row, col;
            size_window(names, cnt, &row, &col);
            DBG(GREEN"<Dbuge>"NONE" : row = %d, col = %d\n", row, col);
            show_files(names, cnt, row, col);
        }
    }
    return ;
}


char *uid_to_name(uid_t uid) {//用户id转为用户名
    struct passwd *pw_ptr;
    static char tmpstr[10] = {0};
    if ((pw_ptr = getpwuid(uid)) == NULL) {
        sprintf(tmpstr, "%d", uid);
        return tmpstr;
    } else {
        return pw_ptr->pw_name;
    }
}

char *gid_to_name(gid_t gid) {
    struct group *gr_ptr;
    static char tmpstr[10] = {0};
    if ((gr_ptr = getgrgid(gid)) == NULL) {
        sprintf(tmpstr, "%d", gid);
        return tmpstr;
    } else {
        return gr_ptr->gr_name;
    }
}

void mode_to_str(mode_t mode, char *modestr) {

    strcpy(modestr, "----------");
    if (S_ISREG(mode)) modestr[0] = '-';//是否为一般文件
    if (S_ISDIR(mode)) modestr[0] = 'd';//是否为目录
    if (S_ISCHR(mode)) modestr[0] = 'c';//是否为字符装置文件
    if (S_ISBLK(mode)) modestr[0] = 'b';//是否为先进先出
    if (S_ISSOCK(mode)) modestr[0] = 's';//是否为socket
    if (S_ISFIFO(mode)) modestr[0] = 'p';//是否为命名管道
    if (S_ISLNK(mode)) modestr[0] = 'l';//是否为符号链接

    if (S_IRUSR & mode) modestr[1] = 'r';
    if (S_IWUSR & mode) modestr[2] = 'w';
    if (S_IXUSR & mode) modestr[3] = 'x';

    if (S_IRGRP & mode) modestr[4] = 'r';
    if (S_IWGRP & mode) modestr[5] = 'w';
    if (S_IXGRP & mode) modestr[6] = 'x';
    
    if (S_IROTH & mode) modestr[7] = 'r';
    if (S_IWOTH & mode) modestr[8] = 'w';
    if (S_IXOTH & mode) modestr[9] = 'x';
    update_color(mode);
}


void show_info (char *filename, struct stat *st) {
    char modestr[15] = {0};
    mode_to_str(st->st_mode, modestr);//获取权限
    printf("%s ", modestr);
    printf("%4ld ", st->st_nlink);//文件数
    printf("%10s ", uid_to_name(st->st_uid));//用户名，st_uid是用户的id
    printf("%10s ", gid_to_name(st->st_gid));//所属的组
    printf("%10ld ", st->st_size);//文件大小
    printf("%.15s ", 4 + ctime(&st->st_mtime));//上次状态更改时间
    printf("\033[%d;%dm%s\033[0m ",bg_c, fg_c, filename);//文件名
}

```







## GETOPT() : 设置的一些全局变量

| 头文件   | #include <unistd.h>                                          |
| -------- | ------------------------------------------------------------ |
| 函数定义 | int getopt(int argc, char * const argv[],                   const char *optstring); |
| 函数声明 | char *optarg  —— 指向当前选项参数(如果有)的指针。<br/><br/>·int optind  一再次调用getopt()时的下一个argv指针的索引。//循环的当前操作的第一个选项的位置<br/><br/>int optopt   ——最后一个已知选项。<br/><br/>int opterr    —这个变量非常时，向stderr打印错误。默认为1。 |
| 返回值   | 函数到达末尾返回-1;                                          |



![img](https://ese3a9b6c5d0ic.prissl.qiqiuyun.net/coursematerial-36/20200319112505-26tltlq4lbpcskow/212ff7128fea272f_img5?e=1595686146&token=ExRD5wolmUnwwITVeSEXDQXizfxTRp7vnaMKJbO-:T1f7auoYNkKSj0EDNnOypWGDJt8=)

![img](https://ese3a9b6c5d0ic.prissl.qiqiuyun.net/coursematerial-36/20200319112505-26tltlq4lbpcskow/212ff7128fea272f_img6?e=1595686146&token=ExRD5wolmUnwwITVeSEXDQXizfxTRp7vnaMKJbO-:wz3t9eh-Txt_sUpyCJrvCqaYO0E=)

getopt处理以'-’开头的命令行参数，如optstring="ab:c::d::",命令行为getopt.exe -a -b host -ckeke -d haha 

在这个命令行参数中，-a和-h就是选项元素，去掉'-'，a,b,c就是选项





exit(0);正常退出;

exit(x) x != 0, 异常退出.

## exit()和return的区别

​	按照ANSI C，在最初调用的main()中使用return和exit()的效果相同。但要注意这里所说的是“最初调用”。

​		如果main()在一个递归程序中，exit()仍然会终止程序；但return将

控制权移交给递归的前一级，直到最初的那一级，此时return才会终止程序。

​		return和exit()的另一个区别在于，即使在除main()之外的函数中调用exit()，它也将终止程序



##  opendir（打开目录）

|          |                                                              |
| -------- | ------------------------------------------------------------ |
| 相关函数 | open，readdir，closedir，rewinddir，seekdir，telldir，scandir |
| 表头文件 | #include<sys/types.h>   #include<dirent.h>                   |
| 定义函数 | ==DIR== * opendir(const char * name); //name是目录名         |
| 函数说明 | opendir()用来打开参数name指定的目录，并返回DIR*形态的目录流，和open()类似，接下来对目录的读取和搜索都要使用此返回值。 |
| 返回值   | 成功则返回指向目录dirname的DIR* 型态的目录流，打开失败则返回NULL。 |
| 错误代码 | EACCESS 权限不足 EMFILE 已达到进程可同时打开的文件数上限。 ENFILE 已达到系统可同时打开的文件数上限。 ENOTDIR 参数name非真正的目录 ENOENT 参数name 指定的目录不存在，或是参数name 为一空字符串。 ENOMEM 核心内存不足。 |

 

##  readdir（遍历读取目录）

 

| 相关函数 | open，opendir，closedir，rewinddir，seekdir，telldir，scandir |
| -------- | ------------------------------------------------------------ |
| 表头文件 | #include<sys/types.h> #include<dirent.h>                     |
| 定义函数 | struct dirent * readdir(DIR * dir);                          |
| 函数说明 | readdir()返回参数dir目录流的下个目录进入点。<br/>Struct dirent { <br/>     ino_t                           d_ino;                          //此目录进入点的inode<br/>    off_t                           d_off;                           //目录文件开头到此目录进入点的位移<br/>    signed  short int      d_reclem;                             //_name的长度，不包含NULL字符<br/>    unsigned  char             d_type;                        // d_name所指的文件类型<br/>    char                           d_name[256];             //文件名<br/>}; |
| 返回值   | 成功则返回下个目录进入点。有错误发生或读取到目录文件尾则返回NULL。 |
| 附加说明 | EBADF参数dir为无效的目录流。                                 |

​	



## chdir() :跳转目录

| 头文件   | #include <unistd.h>                                      |
| -------- | -------------------------------------------------------- |
| 函数定义 | int chdir(const char *path);                             |
| 函数声明 | chdir（）更改调用进程的当前工作目录 到path中指定的目录。 |
| 返回值   | 成功时，返回零。发生错误时，返回-1                       |

 

##  closedir（关闭目录）

|          |                                                     |
| -------- | --------------------------------------------------- |
| 相关函数 | opendir                                             |
| 表头文件 | #include<sys/types.h> #include<dirent.h>            |
| 定义函数 | int closedir(DIR *dir);                             |
| 函数说明 | closedir()关闭参数dir所指的目录流。                 |
| 返回值   | 关闭成功则返回0，失败返回-1，错误原因存于errno 中。 |
| 错误代码 | EBADF 参数dir为无效的目录流                         |
| 范例     | 参考readir()。                                      |



## scandir() : 读取特定的目录数据

| 头文件   | #include <dirent.h>                                          |
| -------- | ------------------------------------------------------------ |
| 函数定义 | int scandir(const char *dir, struct dirent **namelist, int (*select) (const struct dirent *), int  (*compar) (const struct dirent **, const struct dirent**));   第三个参数为0时是升序,为1时是降序. |
| 函数声明 | scandir()会扫描参数dir指定的目录文件，经由参数select指定的函数来挑选目录结构至参数namelist数组中，最后再调用<br/>参数compar指定的函数来排序namelist 数组中的目录数据。每次从目录文件中读取一个目录结构后便将此结构传给参数select所指的<br/>函数， select函数若不想要将此目录结构复制到namelist数组就返回0，若select为空指针则代表选择所有的目录结构。scandir()会<br/>调用 qsort()来排序数据，参数compar则为qsort()的参数，若是要排列目录名称字母则可使用alphasort(). 结构dirent定义请参考<br/>readdir() |
| 返回值   | 成功则返回复制到namelist数组中的数据结构数目，有错误发生则返回-1 |
| Example  | #include <dirent.h><br/>main(){<br/>  struct dirent **namelist;<br/>  int n;<br/>  n = scandir(".", &namelist, 0, alphasort); <br/>  if (n < 0) {<br/>      perror("scandir");<br/>}  else  {<br/>    while(n--) {<br/>      printf("%s\n", namelist[n]->d_name);<br/>      free(namelist[n]);<br/>    }<br/>    free(namelist);<br/>  }<br/>} |







##  stat,lstat:获取文件信息

| 头文件   | #include <sys/types.h><br/>#include <sys/stat.h><br/>#include <unistd.h> |
| -------- | ------------------------------------------------------------ |
| 函数定义 | int stat(const char * path, struct stat * buf);<br/>int fstat(int fd, struct stat * buf);<br/>int lstat(const char * pathname, struct stat * buf);<br/> |
| 函数声明 | 我们经常用ls命令查看到的文件信息，其实都可以使用stat函数组提取出来。<br/>参数fd：文件描述符;<br/>参数*buf：文件信息<br/>参数path：文件路径<br/> |
| 返回值   | 成功为0，否则为-1                                            |



###         1、特别说明：

​        (1) stat() 和 lstat() 都是通过文件路径和文件名访问到文件，然后把文件属性放到 struct stat  *buf中；而 fstat() 是通过文件描述符得到文件的属性。

​        (2) 文件本身没有什么权限限制，但是文件的上层目录必须有访问权限才能获取到文件的属性。

​        (3) 当文件是符号链接时，lstat() 返回的是该符号链接本身的信息；而 stat() 返回的是该该符号链接指向的文件的信息。

### 2.所有的这些系统调用后返回一个stat的结构体，这个结构体包括以下内容：

struct stat {
               dev_t     st_dev;         /* ID of device containing file   文件设备编号*/
               ino_t     st_ino;           /* inode number  节点号*/
               mode_t    st_mode;    /* protection  文件的类型和存取的权限*/
               nlink_t   st_nlink;        /* number of hard links  连到该文件的硬连接数目，刚建立的文件值为1*/
               uid_t     st_uid;           /* user ID of owner   用户ID*/
               gid_t     st_gid;           /* group ID of owner 组ID*/
               dev_t     st_rdev;        /* device ID (if special file)  （设备类型）若此文件尾设备文件，则为其设备编号*/
               off_t     st_size;          /* total size, in bytes  文件字节数（文件大小）*/
               blksize_t st_blksize;  /* blocksize for filesystem I/O   块大小（文件系统的I/O缓冲区大小），类型为unsigned long类型*/
               blkcnt_t  st_blocks;   /* number of 512B blocks allocated  ，分配的512字节的块数，类型为unsigned long类型*/
               time_t    st_atime;     /* time of last access 最后一个访问时间*/
               time_t    st_mtime;    /* time of last modification 最后更改的时间*/
               time_t    st_ctime;     /* time of last status change   inode的更改时间*/
           };

### 3、查看一下stat结构体（man 2 stat）



stat结构体中的st_mode 则定义了下列数种情况：
    

```c++
S_IFMT   0170000    文件类型的位遮罩
S_IFSOCK 0140000    scoket
S_IFLNK 0120000     符号连接
S_IFREG 0100000     一般文件
S_IFBLK 0060000     区块装置
S_IFDIR 0040000     目录
S_IFCHR 0020000     字符装置
S_IFIFO 0010000     先进先出
S_ISGID 02000     文件的(set group-id on execution)位
S_ISVTX 01000     文件的sticky位

S_IRUSR(S_IREAD) 00400     文件所有者具可读取权限
S_IWUSR(S_IWRITE)00200     文件所有者具可写入权限
S_IXUSR(S_IEXEC) 00100     文件所有者具可执行权限

S_IRGRP 00040             用户组具可读取权限
S_IWGRP 00020             用户组具可写入权限
S_IXGRP 00010             用户组具可执行权限

S_IROTH 00004             其他用户具可读取权限
S_IWOTH 00002             其他用户具可写入权限
S_IXOTH 00001             其他用户具可执行权限

上述的文件类型在POSIX中定义了检查这些类型的宏定义：
S_ISLNK (st_mode)    判断是否为符号连接
S_ISREG (st_mode)    是否为一般文件
S_ISDIR (st_mode)    是否为目录
S_ISCHR (st_mode)    是否为字符装置文件
S_ISBLK (s3e)        是否为先进先出
S_ISSOCK (st_mode)   是否为socket
S_ISFIFO(st_mode) 是否为命名管道
```

### 4.stat里面时间辨析

   atime(最近访问时间)

   mtime(最近更改时间)：指最近修改文件内容的时间

   ctime(最近改动时间)：指最近改动Innode的时间，要注意的是mtime信息是Innode中的一项，所以一旦它修改了，这一项也会修改



##  getpwuid ：根据用户id 获取用户名

| 头文件   | #include <pwd.h>                                             |
| -------- | ------------------------------------------------------------ |
| 函数定义 | struct passwd * getpwuid（uid_t uid）;                       |
| 函数声名 | struct passwd <br/>{ <br/>      char * pw_name;       /用户名/ <br/>      char * pw_passwd;     /密码./ <br/>      __uid_t pw_uid;      /用户ID./ <br/>      __gid_t pw_gid;      /组ID./ <br/>      char *　pw_gecos;      /真实名/ <br/>      char *　pw_dir;        /主目录./ <br/>      char *　pw_shell;      /使用的shell/ <br/>}; |
| 返回值   | 如果<pwd.h>中定义了结构，则getpwuid（）函数应返回一个指向结构passwd的指针，如果存在，则具有匹配的条目找到了。如果请求的条目不是，则返回一个空指针。 |





##  getgrgid：根据用户所属组的id 获取用户所属组名

| 头文件   | #include <grp.h>                                             |
| -------- | ------------------------------------------------------------ |
| 函数定义 | struct group *getgrgid(gid_t gid);                           |
| 函数声明 | struct group {<br/>      char   * gr_name;        / group name /     <br/>      char   * gr_passwd;      / group password /   <br/>      gid_t   gr_gid;         / group ID /       <br/>      char  * *  gr_mem;         / NULL-terminated array of pointers  to names of group members */            <br/>}; |
| 返回值   | 成功完成后，getgrgid（）应该返回指向具有<grp.h>中定义的结构的结构组的指针， 如果没有找到则具有匹配的条目。该getgrgid（）函数将返回一个空指针 |

##  getuid

 uid_t是用宏定义的，是用户ID的专用类型，用来表示用户id。数据类型是unsigned long或者unsigned int。

 uid_t    getuid()

```c++
#include <unistd.h>
#include <sys/types.h>

int main()
 8 {
 9 uid_t uid;
10 uid = getuid();
11 printf("User IDs: uid=%d\n", uid);
12 exit(0);
13 }
```



## time():获取自纪元以来的秒

| 头文件   | #include <time.h>                                            |
| -------- | ------------------------------------------------------------ |
| 函数定义 | time_t time（time_t * tloc ）;                               |
| 函数声明 | time（）以秒为单位返回时间，<br/>       1970-01-01 00:00:00 +0000（UTC）。<br/>       如果tloc为非NULL，则返回值也存储在内存中tloc <br/>       指向。<br/>       法一:t1 = time(0);或t1= time(NULL);将空指针传递给time()函数，并将time()返回值赋给变量t1<br/>        法二:time(&t2);将变量t2的地址作为实参传递给time()函数，函数自动把结果传递给t2，不需要额外的赋值语句。<br/>   [ctime()](https://blog.csdn.net/weixin_43117602/article/details/108774692)将time获得的秒 转换成具体日期. |
| 返回值   | 成功后，返回自纪元以来的时间（以秒为单位）。       出错时，将返回（（time_t）-1），并正确设置errno。 |



##  ctime(): -将秒转还成日期和时间

| 头文件   | \#include <time.h>                                           |
| -------- | ------------------------------------------------------------ |
| 函数定义 | char * ctime（const time_t * clock）;                        |
| 函数声明 | 在的ctime（）函数应指出的时间转换时钟，        代表自大纪元以来的秒数，以秒表示        字符串形式 |
| 返回值   | 在的ctime（）函数将返回由返回的指针asctime（）        并以细分时间为依据。         成功完成后，ctime_r（）应返回一个指向buf指向的        字符串。遇到错误时，为null        指针应返回。 |
| 范例     | ctime(&t2)                                                   |



## access()：判断是否具有存取文件的权限

| 头文件   | #include<unistd.h>                                           |
| -------- | ------------------------------------------------------------ |
| 函数定义 | int access(const char * pathname, int mode);                 |
| 函数声明 | access()会检查是否可以读/写某一已存在的文件。<br/>参数mode有几种情况组合， R_OK，W_OK，X_OK 和F_OK。R_OK，W_OK与X_OK用来检查文件是否具有读取、写入和执行的权限。F_OK则是用来判断该文件是否存在。由于access()只作权限的核查，并不理会文件形态或文件内容，因此，如果一目录表示为“可写入”，表示可以在该目录中建立新文件等操作，而非意味此目录可以被当做文件处理。 |
| 返回值   | 若所有欲查核的权限都通过了检查则返回0值，表示成功，只要有一权限被禁止则返回-1 |



## ioctl() : 获取窗口信息

| 头文件   | #include <sys/ioctl.h>                                       |
| -------- | ------------------------------------------------------------ |
| 函数定义 | int ioctl (int fd, unsignd long request);                    |
| 函数声明 | struct winsize{<br/><br/>unsigned short int ws_row;<br/><br/>unsigned short int ws_col;<br/><br/>unsigned short int ws_xpixel;<br/><br/>unsigned short int ws_ypixel;<br/><br/>}; |
| 返回值   | 通常，成功返回零。一些ioctl（）请求使用<br/>       返回值作为输出参数，并在<br/>       成功时返回非负值。如果出错，则返回-1，并正确设置errno。 |

## qsort() : 排序

| 头文件   | #include <stdlib.h>                                          |
| -------- | ------------------------------------------------------------ |
| 函数定义 | void qsort（void * base ，size_t nmemb ，size_t size ， int（*比较）（const void *，const void *））; |
| 函数声明 | *其中base是排序的一个集合数组，num是这个数组元素的个数，width是一个元素的大小，comp是一个比较函数。<br/>　　比如：对一个长为1000的数组进行排序时，int a[1000]; 那么base应为a，num应为 1000，width应为 sizeof(int)，comp函数随自己的命名。<br/>比较函数必须返回小于，等于，大于零。 |
| 返回值   | 无返回值                                                     |
| 范例     |                                                              |



## strstr(): 查找子字符串

| 头文件   | #include <string.h>                                          |
| -------- | ------------------------------------------------------------ |
| 函数定义 | char * strstr（const char * haystack ，const char * needle ）; |
| 函数声明 | 从字符串haystack中查找 needle字符串第一次出现<br/>所述的strstr（）函数发现字符串的第一个发生        针在串草堆。终止的空字节（'\ 0'）为        没有比较。 |
| 返回值   | 这些函数返回一个指针，指向已定位的开头子字符串，如果找不到子字符串，则为NULL。 |
| 范例     |                                                              |

## bzero()初始化结构体

| 头文件   | #include <string.h>            |
| -------- | ------------------------------ |
| 函数定义 | void bzero(void *s, size_t n); |
| 函数声明 |                                |
| 返回值   | bzero() 函数 无 返回值.        |

bzero();



## 把字符串转换成整型数：atoi()

| 头文件   | \#include  <stdlib.h>                                        |
| -------- | ------------------------------------------------------------ |
| 函数定义 | int atoi(const char *nptr);                                  |
| 函数声明 |                                                              |
| 返回值   | 参数nptr字符串，如果第一个非空格字符存在，是数字或者正负号则开始做类型转换，之后检测到非数字(包括结束符 \0) 字符时停止转换，返回[整型](http://baike.baidu.com/view/1311503.htm)数。否则，返回零。 |









## 

#  cp

```c++
#include <stdio.h>
#include <stdlib.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>
#include <fcntl.h>
#include <string.h>
#define MAX_BUFF 1024
#include "head.h"
//./a.out file1 file2
int main (int argc, char **argv) {
    if(argc != 3) {
        fprintf(stderr, " Usage : %s src dest\n", argv[0]);
        exit(1);
    }
    int fd_in, fd_out;

    if ((fd_in = open(argv[1], O_RDONLY)) == -1) {
        perror("open()");
        exit(1);
    }
;
    if ((fd_out = creat(argv[2], 0666)) == -1) {
        perror("creat()");
        exit(1);
    }

    ssize_t nread, nwrite;
    char buff[MAX_BUFF + 5] = {0};
    while ((nread = read(fd_in, buff, MAX_BUFF))> 0) {
        DBG(GREEN"<Debug> "NONE" nread = %ld\n strlen(buff) = %ld", nread, strlen(buff));
        if ((nwrite = write(fd_out, buff, strlen(buff))) != nread){
            perror("write()");
            exit(1);
        }
        memset(buff, 0, sizeof(buff));
    }
#ifdef _D
    printf("定义了_D\n");
#else
    printf("未定义_D\n");
#endif 
    close (fd_in);
    close(fd_out);
    return 0;
}

```



## write()

#include <unistd.h>

函数定义：ssize_t write (int fd, const void * buf, size_t count); 

函数说明：write()会把参数buf所指的内存写入count个字节到参数fd所指的文件内。

(1)返回值：如果顺利write()会返回实际写入的字节数（len）。当有错误发生时则返回-1，错误代码存入errno中。

（2）write()函数从buf写数据到fd中时，若buf中数据无法一次性读完，那么第二次读buf中数据时，其读位置指针（也就是第二个参数buf）不会自动移动，需要程序员来控制，而不是简单的将buf首地址填入第二参数即可。如可按如下格式实现读位置移动：write(fp, p1+len, (strlen(p1)-len))。 这样write第二次循环时便会从p1+len处写数据到fp, 之后的也一样。由此类推，直至(strlen(p1)-len)变为0。

(3）在write一次可以写的最大数据范围内（貌似是BUFSIZ ,8192），第三参数count大小最好为buf中数据的大小，以免出现错误。

##  read()

函数定义：ssize_t read(int fd, void * buf, size_t count);

函数说明：read()会把参数fd所指的文件传送count 个字节到buf 指针所指的内存中。

返回值：返回值为实际读取到的字节数, 如果返回0, 表示已到达文件尾或是无可读取的数据。若参数count 为0, 则read()不会有作用并返回0。

出错时返回-1;

（1）读常规文件时，在读到count个字节之前已到达文件末尾。例如，距文件末尾还有50个字节而请求读100个字节，则read返回50，下次read将返回0。

（2）对于网络套接字接口，返回值可能小于count，但这不是错误

## fread()和fwrite()

| 头文件   | #include <stdio.h>                                           |
| -------- | ------------------------------------------------------------ |
| 函数定义 | size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream);<br/>size_t fwrite (const void *ptr, size_t size, size _t nmemb, FILE *stream); |
| 函数声明 | 从stream中读nmemb次，每读size，保存到ptr流中.一般读数组或结构变量 |
| 返回值   | 实际读取的元素个数.如果返回值与*count*不相同,则可能文件结尾或发生错误.正确则返回值大于或等于0 |



##  feof（）函数

功能：检测流的文件结束符EOF.
用途：用feof()去判断文件是否结束，若结束，返回非零，若文档未结束，则返回零
工作原理：即使是空的文档，内容里有一个隐藏的“EOF”,在文件的最后，表示资料结束
而对于一个文档，对于feof（）函数，
并非是读到EOF来判断结束，而是在光标位置，往后看，如果有字符，返回零
如果后面没有字符，返回非零
但是对于一空的文档，用feof，往后面看的时候，有一个eof，需要在用getc（FILE*x），取一个字符后，光标后移一位，到了eof处，后面无了，则返回了非零

## open()

 #includ e <sys/types.h>
       #include <sys/stat.h>
       #include <fcntl.h>

```c++
   int open(const char *pathname, int flags);
   int open(const char *pathname, int flags, mode_t mode)
   int creat(const char *pathname, mode_t mode);
```
open () 后可read(),write(), lseek(), fcntl(),

## close()关闭文件

#include <unistd.h >

int close(int fd);

## fclose()关闭流

int fclose (FILE *stream);

## fgets()

#include <stdio.h>

int fgets(FILE *stream) 从stream中读取一个字符

char *fgets(char *s, int size, FILE *stream);从stream流中读size 个字符到s中去，读一行．

int getc(FILE *stream);

int getchar (void);

int ungetc(int c, FILE *stream);还回字符到stream流



# getline()：一般用来读很多行

| 头文件   | # include <stdio.h>                                          |
| -------- | ------------------------------------------------------------ |
| 函数定义 | ssize_t getline(char **lineptr, size_t *n, FILE *stream);    |
| 函数声明 | **lineptr：字符串，getline函数会给它分配一段空间，用来存储读取出来的行内容,结束要释放lineptr.<br/>n**：整型数字，函数调用完后会把分配的空间大小信息记录在n中。这个参数有些鸡肋，在调用getline之前对它进行任何操作都没什么意义，它只会在调用结束后记录lineptr　空间的大小。函数会分配一个n的最大值max_size大小的空间，如果读取的字符数大于等于max_size,则n就是max_size, 如果读取的字符数小于max_size,则重新分配．<br/>**stream**：要读取文件的文件流 |
| 返回值   | 成功的话返回读取到行内容的大小（要加上/n的长度），失败的话返回-1。 |
| 范例     | #define _GNU_SOURCE<br/>       #include <stdio.h><br/>       #include <stdlib.h><br/>　int   main(int argc, char *argv[]) {<br/>       FILE *stream;<br/>       char *line = NULL;<br/>       size_t len = 0;<br/>       ssize_t nread;<br/><br/>       if (argc != 2) {<br/>           fprintf(stderr, "Usage: %s <file>\n", argv[0]);<br/>           exit(EXIT_FAILURE);<br/>       }<br/><br/>       stream = fopen(argv[1], "r");<br/>       if (stream == NULL) {<br/>           perror("fopen");<br/>           exit(EXIT_FAILURE);<br/>       }<br/><br/>       while ((nread = getline(&line, &len, stream)) != -1) {<br/>           printf("Retrieved line of length %zu:\n", nread);<br/>           fwrite(line, nread, 1, stdout);<br/>       }<br/><br/>       free(line);<br/>       fclose(stream);<br/>       exit(EXIT_SUCCESS);<br/>   } |





# cat

````c++
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
void read_file (char *, int , int );
int n = 1,flag_n = 0, flag_b = 0;
int main (int argc, char **argv) {
    int opt;
    while((opt = getopt(argc, argv, "n:: b::")) != -1) {
        switch(opt) {
            case 'n':
                flag_n = 1;
                break;
            case 'b':
                flag_b = 1;
                break;
            default :
                fprintf(stderr, "Usage : %s -n -b !\n", argv[0]);
        }
    }
    if (argc == 1) {
        fprintf(stderr, "Usage : %s file...\n", argv[0]);
        exit(1);
    }
    int i = 1;
    if (argv[1][1] == 'n') i = 2;
    if (argv[1][1] == 'b') i = 2;
    if (argv[1][1] == 'n' && argv[2][1] == 'b') i = 3;
    while (i <= argc - 1) {
        //printf("%s\n", argv[i]);
        read_file(argv[i], flag_n, flag_b);
        i += 1;
    }
    return 0;
}

void read_file(char *pathname, int flag_n, int flag_b) {
    FILE *file = NULL;
    char buff[1024] = {0};
    if ((file = fopen(pathname, "r")) == NULL) {
        perror("fopen");
        exit(1);
    }
    while (fgets(buff, sizeof(buff), file) != NULL) {
        int a = strcmp(buff, "\n");
        if (flag_n && !flag_b) {//-n
            printf("%d %s", n++, buff);
        } else if ((flag_n && flag_b) || (!flag_n && flag_b)) {//-n -b || -b
            if (a) printf("%d %s", n++, buff);
            else printf("%s", buff);
        } else  {
            printf("%s", buff);
        }
        bzero(buff, sizeof(buff));
    }
}

````







## fpintf()



在使用fprintf（）函数的时候，通常我们可以设第一个参数为stdout或者stderr，打印出错调试信息的时候则推荐使用stderr而不是stdout（当输出的信息是错误反馈时）,这是一种惯例，同时也由于内核在处理stdout和stderr时优先级不一样，后者的优先级要高一些，因此有时候如果程序异常退出时，stderr能得到输出，而stdout就不行。

printf(...)实际上相当于fprintf(stdout,...)，这也是我们为什么不推荐使用它的原因。在输出调试信息的时候，我们推荐使用fprintf(stderr,...)，或者使用某个指定的文件流
fprintf(some_stream,...)。

## popen()(在程序中执行shell命令)

| 头文件   | #include <stdio.h>                                           |
| -------- | ------------------------------------------------------------ |
| 函数定义 | FILE *popen(const char *command, const char *type);          |
| 函数声明 | Linux中的popen()函数可以在程序中执行一个shell命令，并返回命令执行的结果。有两种操作模式，分别为读和写。在读模式中，程序中可以读取到命令的输出，其中有一个应用就是获取网络接口的参数。在写模式中，最常用的是创建一个新的文件或开启其他服务等。<br/>       popen()函数通过创建一个管道，调用fork()产生一个子进程，执行一个shell以运行命令来开启一个进程。这个管道必须由pclose()函数关闭，而不是fclose()函数。pclose()函数关闭标准I/O流，等待命令执行结束，然后返回shell的终止状态。如果shell不能被执行，则pclose()返回的终止状态与shell已执行exit一样。<br>        type参数只能是读或者写中的一种，得到的返回值（标准I/O流）也具有和type相应的只读或只写类型。如果type是"r"则文件指针连接到command的标准输出；如果type是"w"则文件指针连接到command的标准输入。<br/>        command参数是一个指向以NULL结束的shell命令字符串的指针。这行命令将被传到bin/sh并使用-c标志，shell将执行这个命令。<br>         popen()的返回值是个标准I/O流，必须由pclose来终止。前面提到这个流是单向的（只能用于读或写）。向这个流写内容相当于写入该命令的标准输入，命令的标准输出和调用popen()的进程相同；与之相反的，从流中读数据相当于读取命令的标准输出，命令的标准输入和调用popen()的进程相同。返回值 |
| 返回值   | 如果调用fork()或pipe()失败，或者不能分配内存将返回NULL，否则返回标准I/O流。popen()没有为内存分配失败设置errno值。如果调用fork()或pipe()时出现错误，errno被设为相应的错误类型。如果type参数不合法，errno将返回EINVAL。 |





## fopen（打开文本文件）

| 头文件   | \#include<stdio.h>                                           |
| -------- | ------------------------------------------------------------ |
| 函数定义 | FILE * fopen(const char * path,const char * mode);           |
| 函数声明 | 参数path字符串包含欲打开的文件路径及文件名，参数mode字符串则代表着流形态。<br/>mode有下列几种形态==字符串==: <br/>r 打开只读文件，该文件必须存在。 <br/>r+ 打开可读写的文件，该文件必须存在。 <br/>w 打开只写文件，若文件存在则文件长度清为0，即该文件内容会消失。若文件不存在则建立该文件。<br/> w+ 打开可读写文件，若文件存在则文件长度清为零，即该文件内容会消失。若文件不存在则建立该文件。<br/>a 以附加的方式打开只写文件。若文件不存在，则会建立该文件，如果文件存在，写入的数据会被加到文件尾，即文件原先的内容会被保留。<br/>a+ 以附加方式打开可读写的文件。若文件不存在，则会建立该文件，如果文件存在，写入的数据会被加到文件尾后，即文件原先的内容会被保留。<br/> 	上 述的形态字符串都可以再加一个b字符，如rb、w+b或ab＋等组合，加入b 字符用来告诉函数库打开的文件为二进制文件，而非纯文字文件。不过在POSIX系统，包含Linux都会忽略该字符。<br/>    由fopen()所建立的新文件会具 S_IRUSR\|S_IWUSR\|S_IRGRP\|S_IWGRP\|S_IROTH\|S_IWOTH(0666)权限，此文件权限也会参考umask 值。 |
| 返回值   | 文件顺利打开后，指向该流的文件指针就会被返回。若果文件打开失败则返回==NULL==，并把错误代码存在errno 中。<br/>附加说明<br/>  一般而言，开文件后会作一些文件读取或写入的动作，若开文件失败，接下来的读写动作也无法顺利进行，所以在fopen()后请作错误判断及处理。 |
| 范例     | #include<stdio.h><br/>main() {<br/>	FILE * fp;<br/>	fp=fopen(“noexist”,”a+”);<br/>	if(fp= =NULL) return;<br/>	fclose(fp);<br/>} |





###  [Linux()sss下open与fopen的区别](https://www.cnblogs.com/hnrainll/archive/2011/09/16/2178706.html)

int open(const char *path, int flag) //flag是标志或属性

int open(const char *path, int access,int mode)
  path 要打开的文件路径和名称 

 access 访问模式，宏定义和含义如下：            
    O_RDONLY     1  只读打开             
    O_WRONLY     2  只写打开             
    O_RDWR      4  读写打开           
    还可选择以下模式与以上3种基本模式相与：          
      O_CREAT   0x0100  创建一个文件并打开        
      O_TRUNC   0x0200  打开一个已存在的文件并将文件长度设置为0，其他属性保持     
      O_EXCL   0x0400  未使用              
      O_APPEND  0x0800  追加打开文件           
      O_TEXT   0x4000  打开文本文件翻译CR-LF控制字符   
      O_BINARY  0x8000  打开二进制字符，不作CR-LF翻译                            
  ==mode 该参数仅在access=O_CREAT方式下使用，其取值如下：==   
    S_IFMT   0xF000  文件类型掩码           
    S_IFDIR   0x4000  目录               
    S_IFIFO   0x1000  FIFO 专用             
    S_IFCHR   0x2000  字符专用             
    S_IFBLK   0x3000  块专用              
    S_IFREG   0x8000  只为0x0000            
    S_IREAD   0x0100  可读               
    S_IWRITE  0x0080  可写               
    S_IEXEC   0x0040  可执行

FILE *fopen(char *filename, char *mode)
  filename 文件名称
  mode 打开模式：                      
    r  只读方式打开一个文本文件              
    rb 只读方式打开一个二进制文件             
    w  只写方式打开一个文本文件              
    wb 只写方式打开一个二进制文件             
    a  追加方式打开一个文本文件              
    ab 追加方式打开一个二进制文件             
    r+ 可读可写方式打开一个文本文件            
    rb+ 可读可写方式打开一个二进制文件           
    w+ 可读可写方式创建一个文本文件            
    wb+ 可读可写方式生成一个二进制文件           
    a+ 可读可写追加方式打开一个文本文件          
    ab+ 可读可写方式追加一个二进制文件

open和fopen的区别：
前者属于低级IO，后者是高级IO。
前者返回一个文件描述符，后者返回一个文件指针。
前者无缓冲，后者有缓冲。
前者与 read, write 等配合使用， 后者与 fread, fwrite等配合使用。
后者是在前者的基础上扩充而来的，在大多数情况下，用后者。

## fgets

**2.** **原型  char \*  fgets(char \* s, int n,FILE \*stream);**

一般用来读一个字符串

fgets读到\t 和\0则结束

  参数：

　　从文件指针stream中读取n-1个字符，存到以s为起始地址的空间里，直到读完一行，如果成功则返回s的指针，否则返回NULL。
　　形参注释：
　　*s：结果数据的首地址；     n：一次读入n-1个数据块的长度,其默认值为1k，即1024;      stream：文件指针

返回值：

​     \1. 当n<=0 时返回NULL，即空指针。

​     \2. 当n=1 时，返回空串"".

​     \3. 如果读入成功，则返回缓冲区的地址。

​     \4. 如果读入错误或遇到文件结尾(EOF)，则返回NULL

读字符串函数fgets函数的功能是从指定的文件中读一个字符串到字符数组中，函数调用的形式为： fgets(字符数组名，n，文件指针)；其中的n是一个正整数。表示从文件中读出的字符串不超过 n-1个字符。在读入的最后一个字符后加上串结束标志'/0'。例如：fgets(str,n,fp);的意义是从fp所指的文件中读出n-1个字符送入字符数组str中。（按行读取）

fgets(...)读入文本行时的两种情况。

1.如果n大于一行的字符串长度，那么当读到字符串末尾的换行符时，fgets(..)会返回。并且在s的最后插入字符串结束标志'\0'。 而s缓冲区剩余的位置不会再填充。

example：

​       123abc

​       fgets(s,10,fp);

​       此时，读入七个字符，123abc\n,实际上还有最后的'\0',所以，strlen(s)=7; 如果要去除末尾的\n，s[strlen(s)-1]='\0';便可。

2.如果n小于等于一行的字符串的长度，那么读入n-1个字符，此时并没有读入\n因为并没有到行尾 ，同样在最后会插入'\0'.

 example:

​      123abc

​      char  s[5];

​      fgets(s,5,fp);

 这时读入4个字符，123a,并没有换行符，所以strlen(s)=4.

 fgets(...)读入整个文件内容，通常用while()循环来使fges()读入文本全部内容，并按行读入。

```c++
1 char s[1024];  
2 while((fgets(s,1024,fp))!=NULL)  
3 {  
4       printf(s);  
5 }  
```

当然如果n小于每行的字符个数，也可以读，只不过读的次数要多。

假设一行为 ： 123456789

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```c++
1 char s[2];  
2 int  num=0;  
3 while((fgets(s,2,fp))!=NULL)  
4 {  
5          printf(s);  
6          n++;  
7 }  
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

每次读入一个字符， 最后也会读完一行，num=10，读了十次，所以，fgets若没遇到换行符，会接着从前一次的位置继续读入n-1个字符,只要是文本流没关闭。

读入空行的情况：

​      第一行  abcdef123

​      第二行            

​      第三行  helloworld

其中第二行为空，fget(..)会把第二行也读入，因为并未到文件结尾。

有时我们并不需要空行，可以这样做：

```c++
1 while((fgets(s,n,fp))!=NULL)  
2 {  
3       if(strlen(s)!=1)//注意这里是1不是0，因为尽管是空行，它也会读入换行符，strlen(s)=1;  
4       printf(s);  
5 }  
```

## bzero()

原型：extern void bzero(void *s, int n); 

用法：#include <string.h> 

功能：置字节字符串s的前n个字节为零。 

说明：bzero无返回值。 





# 多进程

1.进程是操作系统中资源分配与调度的最小单位

2.进程是程序在内存中的镜像;

3.进程不是凭空产生的, 系统中的所有的进程都是由systend进程克隆而来;

4.进程通过fork()函数复制, 而后通过exec()函数来进行:"变身", 去完成各种各样的任务



## 进程的创建

在系统中, 所有的进程都是由1号进程克隆而来, 在我们进行系统编程的时候, 可以使用fork()函数来创建一个子进程,  被克隆的进程叫做父进程.

父子进程在创建后, 基本相同, 除了以下几点:

(1)  子进程的pid是新分配的, 与父进程不同

(2) 子进程的ppid会设置为父进程的pid;

(3) 子进程中的资源统计信息会清零

(4)所有挂起的信号都会被清除, 不会被子进程继承

(5)所有文件锁也不会被子进程继承

### fork() : 创建子进程

| 头文件   | #include <unistd.h>                                          |
| -------- | ------------------------------------------------------------ |
| 函数定义 | pid_t fork(void);                                            |
| 函数声明 | 一个现有进程可以调用fork函数创建一个新进程。由fork创建的新进程被称为子进程（child process）。fork函数被调用一次但返回两次。两次返回的唯一区别是子进程中返回0值而[父进程](https://baike.baidu.com/item/父进程)中返回子进程ID。<br/>子进程是父进程的副本，它将获得父进程数据空间、堆、栈等资源的副本。注意，子进程持有的是上述存储空间的“副本”，这意味着父子进程间不共享这些存储空间。<br/>UNIX将复制父进程的[地址空间](https://baike.baidu.com/item/地址空间)内容给子进程，因此，子进程有了独立的地址空间。在不同的UNIX (Like)系统下，我们无法确定fork之后是子进程先运行还是父进程先运行子进程，这依赖于系统的实现。所以在移植代码的时候我们不应该对此作出任何的假设。 |
| 返回值   | 它不需要参数并返回一个整数值。下面是fork（）返回的不同值。<br/>**负值**：创建子进程失败。<br/>**零**：返回到新创建的子进程。<br/>**正值**：返回父进程或调用者。该值包含新创建的子进程的进程ID [1] 。<br/> |



```c++
#include <stdio.h>
#include <unistd.h>
#include <sys/types.h>
int main {
    pid_t pid;
    if ((pid = fork()) < 0) {
        perror("fork");
        exit(1);
    }
    if (pid == 0) {
        printf("Child Process!\n");
    } else {
        printf("Parent Process!\n");
    }
}

```



## exec() : 替换进程

用exec函数可以把当前进程替换为一个新进程，且新进程与原进程有相同的PID。exec名下是由多个关联函数组成的一个完整系列.

exec函数到底做了什么:

1.改变了地址空间和进程映像;

2.挂起的所有信号都会丢失;

3.后续捕捉到的所有信号都会还原为默认处理方式;

4.丢失所有内存锁;

5.大多数的线程属性会还原为默认值;

6.重置大多数进程相关的统计信息;

7.清空和进程内存地址相关的所有数据, 包含所有映射的文件;

8.清空所有只存在于用户空间的数据.



| 头文件   | <unistd.h>                                                   |
| -------- | ------------------------------------------------------------ |
| 函数定义 | int exxecvpe(const char *file, char *const argv[], char *const envp[]);<br/>int execl(const char *path, const char *arg, .../ * (char  *) NULL   */);<br/>int execlp(const char *file, const char *arg, .../ *  (char * ) NULL * /);<br/>int execle(const char *path, const char *arg, ..., / * (char * )NULL,  char * const envp[] * /);<br/>int execv(const char *path, char *const argv[]);<br/>int execvp(const char *file, char *const argv[]);<br/> |
| 函数声明 | path参数表示你要启动程序的名称包括路径名<br/>arg参数表示启动程序所带的参数，一般第一个参数为要执行命令名，不是带路径且arg必须以NULL结束;<br/>这些函数很好记, 都是以exec开始, 形式为exec [ l v  ][ p e ] :<br/>其中l和v分别表示用列表还是数组(向量)的方式提供参数 <br/>p表示会在用户的path路径下查找可执行文件<br/>e表示会为新进程提供新的环境变量 |
|          | 返回值:成功返回0,失败返回-1                                  |



```c++

#include "head.h"

int main () {
    pid_t pid, pid_w;
    
    if ((pid = fork()) < 0) {
        perror("fork");
        exit(1);
    }

    if (pid == 0) {
        //printf("child Process spid = %d\n", getpid());
        printf("In child Process!\n");
        sleep(1);
        execlp("ls", "ls","/etc",".", NULL);
        printf("BYE!\n");//不会输出, 进程以被替换
    } else {
        pid_w = wait(NULL);
        printf("In parent Process!\n");
    }

    exit(0);
}

```





## 进程的退出

### exit()

status可以使用两个宏定义:EXIT_SUCCESS和EXIT_FAILURE在进程调用exit之后，c库会按顺序完成以下事件：

１．调用任何由atexit()或on)exit()注册的函数；

２．清空所有已打开的标准I/O流

３．删除由tmpfile()函数创建的所有临时文件；完成上面的操作后，exit()会调用_exitI(), 内核接管下面的事：

４．清理进程所创建的，不再使用的所有资源；

５．销毁进程；

６．告知父进程其子进程已被终止

```c++
#include <stdlib.h>
void exit(int status);
```

## wait() & waitppid()

１.子进程活着，　父进程结束，　则子进程变成孤儿进程

２．子进程死了，　但父进程不为其＂收尸（释放资源）＂，则子进程变成僵尸进程

３．孤儿进程可以被１号进程收养，　对系统无害

４，僵尸进程已经不工作，但是依然占有资源吗对系统有害吗需避免　

| 头文件   | #include <sys/types.h><br/>#include <sys/wait.h><br/>        |
| -------- | ------------------------------------------------------------ |
| 函数定义 | pid_t wait (int *status);<br/>pid_t waitpid(pid_t pid, int *status, int options); |
| 函数声明 | wiat和waitpid 最终都会将子进程的退出状态存放在status地址中<br/>waitpid 中的第一个参数pid,可以有以下几个值；<br/>１.pid < -1;等待一个进程组ID 为pid绝对值的任何子进程退出, 如果pid = -500, 则等待进程组ID为500的任何子进程退出；<br/>２．pid = -1 : 等待任何一个子进程退出，　行为和wait()一致；<br/>３．pid = 0:等待同一个进程pid 为pid 的子进程退出.<br/>４．pid > 0: 等待进程pid 为pid的子进程退出.<br/>option参数一般默认为０<br/.> |
| 返回值   | 函数若成功，返回进程ID，若出错则返回-1                       |

## shell脚本的管理锁--flock

| 头文件   |                                                              |
| -------- | ------------------------------------------------------------ |
| 函数定义 | bool flock ( resource $handle , int $operation [, int &$wouldblock ] ) |
| 函数声明 | **operation**<br/>1.LOCK_SH 取得共享锁（读取的程序）<br/>2.LOCK_EX 取得独占锁（写入的程序）<br/>3.LOCK_UN 释放锁定 （无论共享或独占）<br/>4.LOCK_NB 在flock()锁定时不阻塞<br/><br/>使用共享锁LOCK_SH，如果是读取，不需要等待，但如果是写入，需要等待读取完成。<br/>使用独占锁LOCK_EX，无论写入/读取都需要等待。<br/>LOCK_UN，无论使用共享/读占锁，使用完后需要解锁。<br/>LOCK_NB，当被锁定时，不阻塞，而是提示锁定。<br/> |
| 返回值   |                                                              |

```c++
/*************************************************************************
	> File Name: lock1.c
	> Author: 
	> Mail: 
	> Created Time: Sat Aug  1 20:53:34 2020
 ************************************************************************/

#include "head.h"

char lock_file[] = "./.lock";

int main () {
    FILE *lock = fopen(lock_file, "w");
    if (lock == NULL) {
        perror("fopen");
        exit(1);
    }
    flock(lock->_fileno, LOCK_EX);
    sleep(10);
    flock(lock->_fileno, LOCK_UN);
    fclose(lock);
    return 0;
}
```





 

##　多进程实践multi

![深度截图_选择区域_20201019131427](../Documents/深度截图_选择区域_20201019131427.png)





```c++
/*************************************************************************
	> File Name: multi_process.c
	> Author: 
	> Mail: 
	> Created Time: Sat Aug  1 09:54:17 2020
 ************************************************************************/

#include "head.h"

int m_flag = 0;

void open_vim();
int main (int argc, char **argv) {
    int opt;
    char msg[1024] = {"no parameter"};
    while ((opt = getopt(argc, argv, "m:")) != -1) {
        switch (opt) {
            case 'm':
                m_flag = 1;
                break;
            default :
                fprintf(stderr, "Usage : %s -m msg", argv[0]);
                break;
        }
    }

    DBG(GREEN"<Debug>"NONE " : m = %d\n", m_flag);

    argc -= optind;
    argv += optind;
    printf("%d\n", argc);
    if (m_flag == 1) {
        printf("%s\n", msg);
        return 0;
    }

    open_vim();
    return 0;
}

void open_vim() {
    pid_t pid, pid_w;
    if ((pid = fork()) < 0) {
        perror("fork()");
        exit(1);
    } 
    
    if (pid == 0) {
        execlp("vim", "vim", "./tmp.txt", NULL);
    } else {
        wait(NULL);
        execlp("cat", "cat", "./tmp.txt", NULL);
    }
}

```



## 100个子进程

```c++
#include "head.h"

#define max_n 100

int main () {
    pid_t pid;
    int x = 0;
    for (int i = 0; i < max_n; i++) {
        if ((pid = fork()) < 0) {
            perror("fork()");
            DBG(GREEN"<Dbug>"NONE" : %d child have problem\n", i);
            exit(1);
        }
        x = i;
        if (pid == 0) break; //子进程停止循环，跳出．父循环继续生．
    }
    if(pid == 0) {
        printf("I am %d child\n", x);
        DBG(GREEN"<Debug>"NONE" : I am %d child\n", x);
    } else {
        for (int i = 0; i < max_n; i++) {
            wait(NULL);
        }
    }
    return 0;
}


```



## 进程模拟线程

```
#include "head.h"

char num_file[] = "./.num";
char lock_file[] = "./.lock";
struct Num {
    int now, sum;//now 要加的值, 
};

size_t set_num(struct Num *num) {
    FILE *f = fopen(num_file, "w");
    size_t nwrite = fwrite(num, sizeof(struct Num), 1, f);
    fclose(f);
    return nwrite;
}

size_t get_num(struct Num *num) {
    FILE *f = fopen(num_file, "r");
    if (f == NULL) {
        fclose(f);
        perror("fopen_r()");
        return -1;
    }
    size_t nread = fread(num, sizeof(struct Num), 1, f);
    if (nread < 0) {
        fclose(f);
        perror("fread()");
        return -1;
    }
    fclose(f);
    return nread;
}

void do_add(int max, int x) {
    struct Num num;
    while(1) {
        FILE *lock = fopen(lock_file, "w");
        flock(lock->_fileno, LOCK_EX);//等待, 加锁
        if (get_num(&num) < 0) {
            fclose(lock);
            continue;
        }
        DBG(GREEN"<Debug>"NONE" : <%d> now = %d, sum = %d\n", x, num.now, num.sum);
        if (num.now > max) {
            break;
        }
        num.sum += num.now;
        num.now ++;
        set_num(&num);
        flock(lock->_fileno, LOCK_UN);//解锁
        fclose(lock);
    }
}

//./a.out 10000 5
int main (int argc, char **argv) {
    if(argc != 3) {
        fprintf(stderr, "Usage : %s max ins\n", argv[0]);
        exit(1);
    }

    int max = atoi(argv[1]);//atoi()把字符串转换成整形, max最大值
    int ins = atoi(argv[2]);//ins 是进程数
    struct Num num;
    pid_t pid;//进程类型的进程pid
    num.now = 0;
    num.sum = 0;
    int x = 0;
    set_num(&num);
    for (int i = 0; i < ins; i++) {
        if ((pid = fork()) < 0) {
            perror("fork()");
            exit(1);
        }
        x = i;
        if (pid == 0) break;
    }
    if (pid == 0) {
        do_add(max, ins);
        exit(0);
    }

    while (ins) {
        wait(NULL);
        ins--;
    }

    get_num(&num);
    printf("sum = %d\n", num.sum);
    return 0;
}


```





#　共享内存

## 1. shmget()：分配System V共享内存段:

| 头文件   | #include <sys/ipc.h><br/>#include <sys/shm.h>                |
| -------- | ------------------------------------------------------------ |
| 函数定义 | int shmget(key_t key, size_t size, int shmflg);              |
| 函数声明 | shmflg:<br/>**IPC_CREAT** :如果未使用此标志，则shmget（）将查找关联的段如果未使用此标志，则shmget（）将查找关联的段并检查用户是否具有访问段的权限。<br/>**IPC_EXCL**:此标志与IPC_CREAT一起使用，以确保此调用创建段。如果段已存在，调用失败。<br/>SHM_HUGETLB: |
| 返回值   | 成功后，将返回有效的共享内存标识符。出现错误时，返回-1，errno设置为indi‐纠正错误。 |





## 2、SystemV共享内存操作:　shmat()函数

| 头文件   | #include <sys/types.h><br/> #include <sys/shm.h>             |
| -------- | ------------------------------------------------------------ |
| 函数定义 | void *shmat(int shm_id, const void *shm_addr, int shmflg);   |
| 函数声明 | 第一次创建完共享内存时，它还不能被任何进程访问，shmat()函数的作用就是用来启动对该共享内存的访问，并把共享内存连接到当前进程的地址空间。<br/>==第一个参数==，shm_id是由shmget()函数返回的共享内存==标识==。<br/>第二个参数，shm_addr指定共享内存连接到当前进程中的地址位置，通常为空，表示让系统来选择共享内存的地址。<br/>第三个参数，shm_flg是一组标志位，通常为0。<br/> |
| 返回值   | 调用成功时返回一个指向共享内存第一个字节的指针，如果调用失败返回-1. |





## 3. ftok-将路径名和项目标识符转换为System V IPC键

   系统建立IPC通讯（如消息队列、共享内存时）必须指定一个ID值。通常情况下，该id值通过ftok函数得到。

| 头文件   | \#include <sys / types.h><br/>\#include <sys / ipc.h>        |
| -------- | ------------------------------------------------------------ |
| 函数定义 | key_t ftok（const char * pathname ，int proj_id ）;          |
| 函数声明 | 所述ftok（）函数使用由给定的指定的文件的标识的路径名（其必须引用现有，访问的文件）和中的至少显著8位PROJ_ID（其必须为非零），以生成一个的key_t类型系统V IPC键，适用于msgget（2),semget（2）或shmget（2）。 当使用相同的proj_id值时，对于命名相同文件的所有路径名，结果值均相同。当（同时存在）文件或文件同时存在时，返回的值应该不同。项目ID有所不同。 |
| 返回值   | **成功**后，将返回生成的key_t值。**失败**返回 -1，           |



## 范例:add

```c++
#include "head.h"

struct Num {
    int now, sum;
    pthread_mutex_t mutex;
};

struct Num *share_memory = NULL;

void do_add(int max, int x) {
    while(1) {
        pthread_mutex_lock(&share_memory->mutex);
        DBG(GREEN"<Debug>"NONE" : <%d> now = %d, sum = %d\n", x, share_memory->now, share_memory->sum);
        if (share_memory->now > max) {
            pthread_mutex_unlock(&share_memory->mutex);
            break;
        }

        share_memory->sum += share_memory->now;
        share_memory->now++;
        pthread_mutex_unlock(&share_memory->mutex);
        usleep(20);
    }
}


int main (int argc, char **argv) {
    if (argc != 3) {
        fprintf(stderr, "Usage : %s max ins\n", argv[0]);
        exit(1);
    }
    int max = atoi(argv[1]);
    int ins = atoi(argv[2]);

    pid_t pid;
    int shmid;
    key_t key = ftok(".", 2009);
    if (shmid = shmget(key, sizeof(struct Num), IPC_CREAT | 0666) < 0) {
        perror("shmget()");
        exit(1);
    }

    if ((share_memory = (struct Num *)shmat(shmid, NULL, 0)) == NULL) {
        perror("shmat()");
        exit(1);
    }

    memset(share_memory, 0, sizeof(struct Num));
    pthread_mutexattr_t attr;
    pthread_mutexattr_init(&attr);//初始化属性
 　 pthread_mutexattr_setpshared(&attr,PTHREAD_PROCESS_SHARED);//PTHREAD_PROCESS_SHREAD可共享，锁是进程的, //因为锁是线程的, 进程要用需共享
    pthread_mutex_init(&share_memory->mutex, &attr);//初始化锁
    int x = 0;
    for (int i = 0; i < ins; i++) {
        if ((pid = fork()) < 0) {
            perror("fork()");
            exit(1);
        }

        x = i;
        if (pid == 0) break;
    }
    if (pid == 0) {
        do_add(max, x);
        exit(0);
    }

    while (ins) {
        wait(NULL);
        ins--;
    } 

    printf("sum = %d\n", share_memory->sum);
}

```





## semtl（）:

#头文件

\#include <sys / types.h>
\#include <sys / ipc.h>
\#include <sys / sem.h>

 函数

```
   int semctl（int semid ，int semnum ，int cmd ，...）;
```

系统调用semctl用来执行在信号量集上的控制操作。这和在消息队列中的系统调用msgctl是十分相似的。但这两个系统调用的参数略有不同。

semid 信号量的标志码(ID)，也就是semget（）函数的返回值;

semnum, 操作信号在信号集中的编号。从0开始。

cmd 命令，表示要进行的操作。

参数cmd中可以使用的命令如下：

·IPC_STAT读取一个信号量集的数据结构semid_ds，并将其存储在semun中的buf参数中。
·IPC_SET设置信号量集的数据结构semid_ds中的元素ipc_perm，其值取自semun中的buf参数。
·IPC_RMID将信号量集从内存中删除。
·GETALL用于读取信号量集中的所有信号量的值。
·GETNCNT返回正在等待资源的进程数目。
·GETPID返回最后一个执行semop操作的进程的PID。
·GETVAL返回信号量集中的一个单个的信号量的值。
·GETZCNT返回正在等待完全空闲的资源的进程数目。
·SETALL设置信号量集中的所有的信号量的值。
·SETVAL设置信号量集中的一个单独的信号量的值。

此函数具有三个或四个参数，具体取决于cmd。当
有四个时，第四个具有union semun类型。
union semun {
int val; / * SETVAL的值* /
struct semid_ds *buf; / \* IPC_STAT，IPC_SET的缓冲区* /
unsigned short *array; / \* GETALL，SETALL的数组* /
struct seminfo *__buf; / \* IPC_INFO的缓冲区（特定于Linux）* /
};

```
       struct semid_ds {
           struct ipc_perm sem_perm; 　/ *所有权和权限* / 
           time_t          sem_otime; 　/ *最后一次采样时间* / 
           time_t          sem_ctime; / *创建时间/最后时间通过semctl（）* /                         
           unsigned long   sem_nsems; / *集合中信号灯的数量* / 
       };
```

 返回值

返回值：如果成功，则为一个正数。
如果失败，则为-1：errno=EACCES(权限不够)

## 例子

```
static int init_semval(int val) {
    union semun sem_set;
    sem_set.val = val;
    if (semctl(sem_id, 0, SETVAL, sem_set) == - 1) {
        perror("semctl");
        return 0;
    }
    return 1;
}
```

 

##  semop()

| 头文件   | \#include <sys / types.h><br/>#include <sys / ipc.h><br/>#include <sys / sem.h><br/> |
| -------- | ------------------------------------------------------------ |
| 函数定义 | int semop（int semid ，struct sembuf * sops ，size_t nsops ）;<br/>功能：用户改变信号量的值。也就是使用资源还是释放资源使用权。 |
| 函数声明 | **semid ** :信号量的标识码。也就是semget（）的返回值。<br/>**sops**: 是一个指向结构体数组的指针。<br/> sem_op = -1,进行p操作 , 　即对信号量进行减一操作；<br/>sen_op = 1; 进行V 操作，即释放资源．<br/>_semflg ：IPC_NOWAIT //对信号的操作不能满足时，semop()不会阻塞，并立即返回，同时设定错误信息。<br/>IPC_UNDO //程序结束时(不论正常或不正常)，保证信号值会被重设为semop()调用前的值。这样做的目的在于避免程序在异常情况下结束时未将锁定的资源解锁，造成该资源永远锁定。<br/>sem_num: 操作信号在信号集中的编号。第一个信号的编号为0<br/> |
| 返回值   | 成功返回0，失败返回-1；                                      |

```c++
struct sembuf{
     unsigned short  sem_num;//第几个信号量，第一个信号量为0；
     short  sem_op;//对该信号量的操作．
     short _semflg;
};
```



## 例子

[semctl()](https://blog.csdn.net/weixin_43117602/article/details/108815990)

[semget()](https://blog.csdn.net/weixin_43117602/article/details/108815692)

```
#include "head.h"

int sem_id, um_num, stu_num;
union semun {
    int val;
    struct semid_ds *buf;
    unsigned short *array;
    struct seminfo *_buff;
};

static int init_semval(int val) {
    union semun sem_set;
    sem_set.val = val;
    if (semctl(sem_id, 0, SETVAL, sem_set) == - 1) {
        perror("semctl");
        return 0;
    }
    return 1;
}

static int del_semval() {
    union semun sem_del;
    if (semctl(sem_id, 0, IPC_RMID, sem_del) == -1) {
        perror("sem_del");
        return 0;
    }
    return 1;
}

static int sem_pv(int op) {
    //p : -1, v +1;
    struct sembuf sem_pv;
    sem_pv.sem_num = 0;
    sem_pv.sem_op = op;
    sem_pv.sem_flg = SEM_UNDO;//程序结束时(不论正常或不正常)，保证信号值会被重设为semop()调用前的值。
    if (semop(sem_id, &sem_pv, 1) == - 1) {//第三个参数是操作的数量
        perror("semop");
        return 0;
    }
    return 1;
}

int P() {
    return sem_pv(-1);
}
int V() {
    return sem_pv(1);
}
void *func(void *arg) {
    int tmp = *(int *)arg;
    time_t t;
    int i = 3;
    while(i--) {
        int time_out = rand() % 10;
        sleep(time_out);
        int j = 0;
        while(um_num == 0) sleep(++j);
        if (!P()) {
            perror("sem_p");
        }
        time(&t);
        printf(GREEN"student %d out at %s"RED"umbrella have %d\n\n"NONE, tmp, ctime(&t), --um_num);
        fflush(stdout);
        int time_on = rand() % 10;
        sleep(time_on);
        if (!V()) {
            perror("sem_v");
        }
        time(&t);
        printf(BLUE"student %d have back at %s"RED"umbrella have %d\n\n"NONE, tmp, ctime(&t), ++um_num);
    }
    sleep(1);
    printf("stdeunt %d have finish!\n", tmp);
}



int main(int argc, char **argv) {
    int opt;
    int flag_s = 0, flag_u = 0;
    while((opt = getopt(argc, argv, "s:u:")) != -1) {
        switch(opt) {
            case 's' :
                flag_s = 1;
                stu_num = atoi(optarg);
                break;
            case 'u' :
                flag_u = 1;
                um_num = atoi(optarg);
                break;
            default :
                fprintf(stderr, "Usage: %s -s -u!\n", argv[0]);
        }
    }
    if (!flag_s || !flag_u || argc < 5) {
        fprintf(stderr, "Usage : %s stu_num um_num!\n", argv[0]);
        exit(1);
    }

    printf(YELLOW"It started raining outside! room have %d students have %d umbrella!\n\n"NONE, stu_num, um_num);
    key_t mykey;
    mykey = ftok("key", 1000);
    if ((sem_id = semget(mykey, 1, IPC_CREAT | 0666)) == -1) {
        perror("semget failed");
        exit(1);
    }
    if(!init_semval(um_num)) {
        perror("init");
        return 1;
    }
    pthread_t tid[stu_num + 5];
    int stu[10];
    for (int i = 0; i < stu_num; i++) {
        stu[i] = i;
        pthread_create(&tid[i], NULL, func, (void *)&stu[i]);
    }
    for (int i = 0; i < stu_num; i++) {
        pthread_join(tid[i], NULL);
    }
    sleep(3);
    printf(YELLOW"Rain have stop!room have student %d, have umbrella %d\n"NONE, stu_num, um_num);
    del_semval();
    return 0;
}
```







# 线程

1.线程是操作系统调度器的最小执行单位;

2.现代操作系统实现了两种对用户空间的基础虚拟抽象:虚拟内存和虚拟处理器;

3.进程感觉自己独占了内存, 而线程感觉自己独占了处理器;

4.一个进程至少包含了一个线程, 一个进程的多个线程共享内存空间;

5每个线程都独立调度, 调度和切换的代价低于进程



多线程的好处

1.编程抽象模块化

2.增加程序的并发性

3.提高响应能力

4.IO阻塞可行

5.上下文切换代价小

6.内存保存, 线程之间共享内存, 切换无需置换内存;



## 创建



| 头文件   | #include <pthread.h>                                         |
| -------- | ------------------------------------------------------------ |
| 函数定义 | int pthread_create(pthread_t *thread, const pthread_attr_t *attr, void *(*start_routine) (void *), void *arg) |
| 函数声明 | 参数thread:如果线程创建成功，　将会把线程的ID保存到thread指向的空间；<br/>参数attr：用于改变新创建线程的默认线程属性，一般默认NULL就可以；<br/>参数start_routine:线程执行函数，　形式应类似为　----　void * start_thread(void *arg):<br/>      1.参数为void 指针<br/>      2.返回值也是void指针<br/>参数arg：arg为传递给第三个参数，　也就是线程执行函数的参数，　需要注意的是，如果要传递多个参数，　应该用结构体封装． |
| 返回值   | 成功时，pthread_create（）返回0；出错时，返回错误号，*thread的内容为未定义． |



## 线程终止

线程的自杀

```c++
#include <pthread.h>
void pthread_exit(void *retval);
pthread_exit(NULL);
```

线程的他杀	

```c++
#include <pthread.h>
int pthread_cancel(pthread_t thread);
pthread_cancel(you);
```

## 线程的等待和分离

由于线程创建和摧毁很容易，　必须对线程进程同步的机制，　避免被其他线程终止，　对应的线程即wait()，　也就是join线程；

线程join:支持一个线程阻塞，等待另一个线程终止



| 头文件   | #include <pthread.h>                                         |
| -------- | ------------------------------------------------------------ |
| 函数定义 | int pthread_join(pthread_t thread, void **retval);           |
| 函数声明 | 函数的作用是：等待线程指定的线程终止。如果该线程已经终止，则pthread_join（）立即返回。线程指定的线程必须是可接合的。如果retval不为NULL，那么pthread_join（）将复制目标线程的退出状态（即目标线程提供的值pthread_exit（3））到*retval指定的位置。如果目标线程被取消，则PTHREAD_canceled将被放入*回溯。如果多个线程同时尝试与同一线程联接，则结果未定义。如果调用pthread_join（）的线程是取消，则目标线程将保持可接合（即，它将不会被分离）。 |
| 返回值   | On success, pthread_join() returns 0; on error, it returns an error number. |







线程detach：默认情况下，　线程都可join的，　detach可以让其不可join

```
#include <pthread.h>
int pthread_detach(pthread_t thread);
```



## 线程的创建和加入范例

```c++
#include "head.h"

void *print(void *arg) {
    //int tmp = *(int *)arg;
    DBG(GREEN"<Debug>"NONE " : I am  %d  child\n", *(int *)arg);
    //printf("i am %d child\n", tmp);
}

int main (int argc, char **argv) {
    int tmp_arg[100] = {0};
    pthread_t tid[100];
    for (int i = 1; i <= 100; i++) {
        tmp_arg[i] = i;
         //此处i变量的用法是方便大家调测代码的写法，实际使用会有问题，因为这个t是局部变量，
        //函数执行完后马上释放，大家传递参数时需要使用全局变量或malloc出来的变量。
        pthread_create(&tid[i], NULL, print, (void *)&tmp_arg[i]);
        //sleep(0);
    }
    for (int i = 1; i <= 100; i++) {
        pthread_join(tid[i], NULL);
    }
    //sleep(4);
    return 0;
}

```

## 线程对结构体的操作范例

```
#include "head.h"

struct Arg {
    char name[20];
    int age;
} Arg;

struct Arg arg_in;

void *print(void *arg) {
        struct Arg tmp = *(struct Arg *)arg;
        printf("helle HaiZei %s, he is %d years old!\n", tmp.name, tmp.age);
    }

int main (){
    pthread_t tid;
    arg_in. age = 18;
    strcpy(arg_in.name, "zhouyuan");
    pthread_create(&tid, NULL,print, (void *)&arg_in);
    sleep(1);
    return 0;
}

```





## 互斥锁（ 线程的）

| 头文件   | #include <pthread.h>                                         |
| -------- | ------------------------------------------------------------ |
| 函数定义 | pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;<br/>int pthread_mutex_lock(pthread_mutex_t *mutex);//加锁<br/>int pthread_mutex_unlock(pthread_mutex_t *mutex);//解锁<br/>int pthread_mutex_destory(pthread_mutex_t *mutex);//摧毁<br/>int pthread_mutexattr_init(pthread_mutexattr_t *attr);//初始化属性<br/>int pthread_mutex_init(pthread_mutex_t  *mutex, pthread_mutexattr_t  *attr);//初始化锁<br/>int pthread_mutexattr_settype(pthread_mutexattr_t *attr, int kind);<br/>int pthread_mutexattr_gettype(const pthread_mutexattr_t *attr, int *kind);<br/> int pthread_mutexattr_getpshared(const pthread_mutexattr_t  *restrict attr, int *restrict pshared);//看有没有共享<br/> int pthread_mutexattr_setpshared(pthread_mutexattr_t *attr,　int pshared);//进程共享锁 |
| 函数声明 | pshared：　PTHREAD_PROCESS_SHARED，　PTHREAD_PROCESS_PRIVATE |
| 返回值   | pthread_mutexattr_init、pthread_mutexattr_destroy和pthread_mutexattr_gettype始终返回0。<br/>pthread_mutexattr_settype成功时返回0，出错时返回非零错误代码。 |





![深度截图_选择区域_20201019131704](../Documents/深度截图_选择区域_20201019131704.png)







## 线程互斥锁范例(多线程)

```c++
#include "head.h"
#define INS 5
#define max_n 1000
pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;
int now = 0, sum = 0;


void *add(void *arg) {
    while (1) {
        pthread_mutex_lock(&mutex);
        if (now >= max_n) {
            pthread_mutex_unlock(&mutex);
            break;
        } 
        now++;
        sum += now;
        pthread_mutex_unlock(&mutex);
        printf("<%ld>%d\n",pthread_self(),  now);
        usleep(20);//微秒
    }
}

int main () {
    pid_t pid;
   
    pthread_t tid[INS];
    int path_i[5];
    for (int i = 0; i < INS; i++) {
            pthread_create(&tid[i], NULL, add, NULL);
    }

    for (int i = 0; i < INS; i++) {
        pthread_join(tid[i], NULL);
    }
    printf("sum = %d\n", sum);
    return 0;
}

```



范例（结构体）

```c++
#include "head.h"

struct Arg {
    char name[20];
    int age;
} Arg;

struct Arg arg_in;

void *print(void *arg) {
        struct Arg tmp = *(struct Arg *)arg;
        printf("helle HaiZei %s, he is %d years old!\n", tmp.name, tmp.age);
    }

int main (){
    pthread_t tid;
    arg_in. age = 18;
    strcpy(arg_in.name, "zhouyuan");
    pthread_create(&tid, NULL,print, (void *)&arg_in);
    sleep(1);
    return 0;
}

```

## 进程与线程的选择取决以下几点：

1、需要频繁创建销毁的优先使用线程；因为对进程来说创建和销毁一个进程代价是很大的。

2、线程的切换速度快，所以在需要大量计算，切换频繁时用线程，还有耗时的操作使用线程可提高应用程序的响应

3、因为对CPU系统的效率使用上线程更占优，所以可能要发展到多机分布的用进程，多核分布用线程；

4、并行操作时使用线程，如C/S[架构](http://lib.csdn.net/base/architecture)的服务器端并发线程响应用户的请求；

5、需要更稳定安全时，适合选择进程；需要速度时，选择线程更好。



**1）需要频繁创建销毁的优先用线程**

原因请看上面的对比。

这种原则最常见的应用就是Web服务器了，来一个连接建立一个线程，断了就销毁线程，要是用进程，创建和销毁的代价是很难承受的

**2）需要进行大量计算的优先使用线程**

所谓大量计算，当然就是要耗费很多CPU，切换频繁了，这种情况下线程是最合适的。

这种原则最常见的是图像处理、算法处理。

**3）强相关的处理用线程，弱相关的处理用进程**

什么叫强相关、弱相关？理论上很难定义，给个简单的例子就明白了。

一般的Server需要完成如下任务：消息收发、消息处理。“消息收发”和“消息处理”就是弱相关的任务，而“消息处理”里面可能又分为“消息解码”、“业务处理”，这两个任务相对来说相关性就要强多了。因此“消息收发”和“消息处理”可以分进程设计，“消息解码”、“业务处理”可以分线程设计。

当然这种划分方式不是一成不变的，也可以根据实际情况进行调整。

**4）可能要扩展到多机分布的用进程，多核分布的用线程**

原因请看上面对比。

**5）都满足需求的情况下，用你最熟悉、最拿手的方式**

至于“数据共享、同步”、“编程、调试”、“可靠性”这几个维度的所谓的“复杂、简单”应该怎么取舍，我只能说：没有明确的选择方法。但我可以告诉你一个选择原则：如果多进程和多线程都能够满足要求，那么选择你最熟悉、最拿手的那个。 

需要提醒的是：虽然我给了这么多的选择原则，但实际应用中基本上都是“进程+线程”的结合方式，千万不要真的陷入一种非此即彼的误区。

 

**消耗资源：**

从内核的观点看，进程的目的就是担当分配系统资源（CPU时间、内存等）的基本单位。线程是进程的一个执行流，是CPU调度和分派的基本单位，它是比进程更小的能独立运行的基本单位。

线程，它们彼此之间使用相同的地址空间，共享大部分数据，启动一个线程所花费的空间远远小于启动一个进程所花费的空间，而且，线程间彼此切换所需的时间也远远小于进程间切换所需要的时间。据统计，总的说来，一个进程的开销大约是一个线程开销的30倍左右，当然，在具体的系统上，这个数据可能会有较大的区别。

**通讯方式：**

进程之间传递数据只能是通过通讯的方式，即费时又不方便。线程时间数据大部分共享（线程函数内部不共享），快捷方便。但是数据同步需要锁对于static变量尤其注意

**线程自身优势：**

提高应用程序响应；使多CPU系统更加有效。**操作系统会保证当线程数不大于CPU数目时，不同的线程运行于不同的CPU上；**

改善程序结构。一个既长又复杂的进程可以考虑分为多个线程，成为几个独立或半独立的运行部分，这样的程序会利于理解和修改。



### add

```c++

```



### printf

```c++
#include "head.h"
#define MAXSIZE 1024
struct Num {
    char buff[MAXSIZE];
    pthread_mutex_t mutex;
};

struct Num *share_memory = NULL;

void do_printf() {
    while(1) {
        if (strlen(share_memory->buff)) {
            pthread_mutex_lock(&share_memory->mutex);
            DBG(GREEN"<Debug>"NONE" : locked in Parent\n")
            printf(RED"<Parent>"NONE" : %s\n",share_memory->buff);
            memset(share_memory->buff, 0, sizeof(share_memory->buff));
            pthread_mutex_unlock(&share_memory->mutex);
        }
    }
}


int main (int argc, char **argv) {
    pid_t pid;
    int shmid;
    key_t key = ftok(".", 2109);
    if (shmid = shmget(key, sizeof(struct Num), IPC_CREAT | 0666) < 0) {
        perror("shmget()");
        exit(1);
    }

    if ((share_memory = (struct Num *)shmat(shmid, NULL, 0)) == NULL) {
        perror("shmat()");
        exit(1);
    }

    memset(share_memory, 0, sizeof(struct Num));
    pthread_mutexattr_t attr;
    pthread_mutexattr_init(&attr);
    pthread_mutexattr_setpshared(&attr, PTHREAD_PROCESS_SHARED);//PTHREAD_PROCESS_SHREAD可共享，锁是进程的
    pthread_mutex_init(&share_memory->mutex, &attr);
    if ((pid = fork()) < 0) {
        perror("fork()");
        exit(1);
    }

    if (pid == 0) {
        while(1) {
            if (strlen(share_memory->buff)) continue;
                pthread_mutex_lock(&share_memory->mutex);
                DBG(GREEN"<Debug>"NONE " : locked in child\n");
                printf("child input:");
                scanf("%[^\n]s", share_memory->buff);
                getchar();
                DBG(PINK"<Child>"NONE" : %s\n", share_memory->buff);
                pthread_mutex_unlock(&share_memory->mutex);
                //usleep(20);
        }
    } else {
        do_printf();
        wait(NULL);
    }
   
}

```















　

# Linux进程间通信：共享内存

下面将讲解进程间通信的另一种方式，使用共享内存。

### 一、什么是共享内存

顾名思义，共享内存就是允许两个不相关的进程访问同一个逻辑内存。共享内存是在两个正在运行的进程之间共享和传递数据的一种非常有效的方式。不同进程之间共享的内存通常安排为同一段物理内存。进程可以将同一段共享内存连接到它们自己的地址空间中，所有进程都可以访问共享内存中的地址，就好像它们是由用C语言函数malloc()分配的内存一样。而如果某个进程向共享内存写入数据，所做的改动将立即影响到可以访问同一段共享内存的任何其他进程。

特别提醒：共享内存并未提供同步机制，也就是说，在第一个进程结束对共享内存的写操作之前，并无自动机制可以阻止第二个进程开始对它进行读取。所以我们通常需要用其他的机制来同步对共享内存的访问，例如前面说到的信号量。

### 二、共享内存的使得

与信号量一样，在Linux中也提供了一组函数接口用于使用共享内存，而且使用共享共存的接口还与信号量的非常相似，而且比使用信号量的接口来得简单。它们声明在头文件 sys/shm.h 中。



### **3、shmdt()函数   **

该函数用于将共享内存从当前进程中分离。注意，将共享内存分离并不是删除它，只是使该共享内存对当前进程不再可用。它的原型如下：

> int shmdt(const void *shmaddr);

参数shmaddr是shmat()函数返回的地址指针，调用成功时返回0，失败时返回-1.

### **4、shmctl()函数   -- ctl：control**

与信号量的semctl()函数一样，用来控制共享内存，它的原型如下：

> int shmctl(int shm_id, int command, struct shmid_ds *buf);

第一个参数，shm_id是shmget()函数返回的共享内存标识符。

第二个参数，command是要采取的操作，它可以取下面的三个值 ：

- IPC_STAT：把shmid_ds结构中的数据设置为共享内存的当前关联值，即用共享内存的当前关联值覆盖shmid_ds的值。
- IPC_SET：如果进程有足够的权限，就把共享内存的当前关联值设置为shmid_ds结构中给出的值
- IPC_RMID：删除共享内存段

第三个参数，buf是一个结构指针，它指向共享内存模式和访问权限的结构。

shmid_ds结构 至少包括以下成员：

```
struct` `shmid_ds``{``  ``uid_t shm_perm.uid;``  ``uid_t shm_perm.gid;``  ``mode_t shm_perm.mode;``};
```





# 信号



## pthread_mutex_init();

### .函数原型

int pthread_mutex_init(pthread_mutex_t *restrict mutex, const pthread_mutexattr_t   *restrict attr);

功能 :该函数用于C函数的多线程编程中，互斥锁的初始化。

　　**pthread_mutex_init()**函数是以动态方式创建互斥锁的，参数attr指定了新建互斥锁的属性。如果参数attr为NULL，则使用默认的互斥锁属性，默认属性为快速互斥锁 。互斥锁的属性在创建锁的时候指定，在LinuxThreads实现中仅有一个锁类型属性，不同的锁类型在试图对一个已经被锁定的互斥锁加锁时表现不同。

返回值: **pthread_mutexattr_init()**函数成功完成之后会返回零，其他任何返回值都表示出现了错误。

　　函数成功执行后，互斥锁被初始化为锁住态。

　　* PTHREAD_MUTEX_ADAPTIVE_NP，适应锁，动作最简单的锁类型，仅等待解锁后重新竞争。
  *  int pthread_mutextattr_destroy(pthread_mutextattr_t *restrict_mutext)
      该函数是销毁线程互斥锁
      设定互斥锁的作用域：
      Int pthread_mutextattr_setpshared(pthread_mutexattr_t *restrict mutext, int pshared)
      在多线程中是共享互斥锁的。
      如果想在多个进程中共享互斥锁，可以把pshared设置PTHREAD_PROCESS_SHARED
      如果只想在有同属于一个进程创建的线程中共享互斥锁，则可以把pshared设置为PTHREAD_PROCESS_PRIVATE
      获得互斥锁的作用域：
       int pthread_mutexattr_getpshared(pthread_mutexattr_t *restrict mutext,int *pshared);
       设定互斥锁类型的属性：
       int pthread_mutexattr_settype(pthread_mutexattr_t *restrict mutext,int type)
       其中type类型都有：
      PTHREAD_MUTEX_NOMRAL：此类型的互斥锁不会检测死锁
      而其中的缺省值值是PTHREAD_MUTEX_DEFAULT
       PTHREAD_MUTEX_ERRORCHECK:是提供错误检查
       int pthread_mutexattr_setprotocal(pthread_mutexattr_t *attr,int protocal)
       protocal可以设置互斥锁属性的协议
       PTHREAD_PRIO_NONE
       PTHREAD_PRIO_INHERIT
       PTHREAD_PRIO_PROTECT

## 

## 1.kill() : 向进程发送信号

#include <signal.h>

int kill(pid_t pid, int sig);

发给pid一个sig信号



##  getppid() : 获取进程id

| 头文件   | #include <sys/types.h><br/>#iclude <unistd.h>                |
| -------- | ------------------------------------------------------------ |
| 函数定义 | pid_t getpid(void);<br/>   pid_t getppid(void);              |
| 函数声明 |                                                              |
| 返回值   | getpid（）返回调用进程的进程ID。（这通常由生成唯一临时的例程使用文件名。）<br/>getppid（）返回调用进程的父进程的进程ID。 |



## signal()

| 头文件   | #include <signal.h>                                      |
| -------- | -------------------------------------------------------- |
| 函数定义 | sighandler_t  signal( int signum, sighandler_t handler); |
| 函数声明 | 参数signum是信号, handler是信号处理函数                  |
| 返回值   |                                                          |

##  例子

```
/*************************************************************************
	> File Name: pthreadprintf.cpp
	> Author: 
	> Mail: 
	> Created Time: Sun Aug  2 16:34:26 2020
 ************************************************************************/

#include "head.h"
#define MAXSIZE 1024
struct Num {
    char buff[MAXSIZE];
    pthread_mutex_t mutex;
};

struct Num *share_memory = NULL;
./a
void *do_print(int signum) {
    printf(RED"<Parent>"NONE" : %s\n", share_memory->buff);
    memset(share_memory->buff, 0 ,sizeof(share_memory->buff));
    return NULL;
}


int main (int argc, const char **argv) {
    pid_t pid;
    int shmid;
    key_t key = ftok(".", 2020);
    if (shmid = (shmget(key, sizeof(struct Num), IPC_CREAT | 0666)) < 0) {
        perror("shmget()");
        exit(1);
    }

    if ((share_memory = (struct Num *)shmat(shmid, NULL, 0)) == NULL) {
        perror("shmat()");
        exit(1);
    }
    memset(share_memory, 0, sizeof(struct Num));
    if ((pid = fork()) < 0) {
        perror("fork()");
        exit(1);
    }
    if (pid == 0) {
        while(1) {
            printf("Please Input :");
            scanf("%[^\n]s", share_memory->buff);
            DBG(PINK"<Child>"NONE" : %s\n", share_memory->buff);
            getchar();
            kill(getppid(), SIGUSR1);
        }
    } else {
        signal(SIGUSR1, do_print);
        wait(NULL);
    }
    return 0;
}

```



## errno

errno是记录系统的最后一次错误代码。代码是一个int型的值，在errno.h中定义。查看错误代码errno是调试程序的一个重要方法。当linux C api函数发生异常时，通常会出现errno。变量（需包括errno.h）赋值一个整数值，不同的值表示不同的含义，可以通过查看该值提示错误的原因。在实际编程中用这一招解决了很多原本看来莫名其妙的问题。

**注意：**只有当一个[库函数](https://baike.baidu.com/item/库函数)失败时，errno才会被设置。当函数成功运行时，errno的值不会被修改。这意味着我们不能通过测试errno的值来判断是否有错误存在。反之，只有当被调用的函数提示有错误发生时检查errno的值才重置。

　#define EINVAL 22 / *无效参数* /

# 条件变量pthread_cond

```c++
#include <pthread.h>
pthread_cond_t cond = PTHREAD_COND_INITIALIZER
int pthread_cond_init (pthread_cont_t *cond, pthread_condattr_t *cond_attr);
int pthread_cond_signal(pthread_cont_t *cond);
int pthread_cond_broadcast(pthread_cond_t *cond);
int pthread_cond_wait(pthread_cond_t *cond, pthread_mutex_t *mutex);
int pthread_cond_timewait(pthread_cond_t *cond, pthread_mutex_t *mutex, const struct timespec *abstime);
int  pthread_cond_destery(pthread_cond_t);
```

## 聊天室1(singal)

### chat.h

```c++
/*************************************************************************
	> File Name: chat.h
	> Author: 
	> Mail: 
	> Created Time: Tue Aug  4 09:20:57 2020
 ************************************************************************/

#ifndef _CHAT_H
#define _CHAT_H
#include "head.h"
struct Message {
    char name[20];
    char msg[1024];
    pid_t pid;
    pthread_mutex_t mutex;
    pthread_cond_t cond;
};
#endif

```

###  client.c

```c++
/*************************************************************************
	> File Name: client.c
	> Author: 
	> Mail: 
	> Created Time: Tue Aug  4 09:35:30 2020
 ************************************************************************/

#include "chat.h"

struct Message *share_memory = NULL;
struct Message tmp;
int main (int argc, char **argv) {
    int opt;
    while((opt = getopt(argc, argv, "n:")) != -1) {
        switch(opt) {
            case 'n':
                strcpy(tmp.name, optarg);
                break;
            default:
                fprintf(stderr, " Usage : %s -n name!\n",argv[0]);
                break;
        }
    }

    int shmid;
    key_t key = ftok(".", 2011);
    if ((shmid = shmget(key, sizeof(struct Message), IPC_CREAT | 0666)) < 0) {
        perror("shmget()");
        exit(1);
    }
    if ((share_memory = shmat(shmid, NULL, 0)) == NULL) {
        perror("shmat");
        exit(1);
    }

    if (share_memory->pid <= 0) {
        fprintf(stderr, "Please run server first!\n");
    }

    while (1) {
        scanf("%[^\n]s", tmp.msg);
        getchar();
        if (!strlen(tmp.msg)) continue;
        while (1) {
            if (!strlen(share_memory->msg)) {
                pthread_mutex_lock(&share_memory->mutex);
                break;
            }
        }
        strcpy(share_memory->name, tmp.name);
        strcpy(share_memory->msg, tmp.msg);
        pthread_mutex_unlock(&share_memory->mutex);
        kill(share_memory->pid, SIGUSR1);
        memset(tmp.msg, 0, sizeof(tmp.msg));
    }
}

```

### server.c

```c++
/*************************************************************************
	> File Name: server.c
	> Author: 
	> Mail: 
	> Created Time: Tue Aug  4 09:19:46 2020
 ************************************************************************/

#include "chat.h"

struct Message *share_memory = NULL;

void print(int signum) {
    pthread_mutex_lock(&share_memory->mutex);
    printf("<%s> : %s\n", share_memory->name, share_memory->msg);
    memset(share_memory->msg, 0, sizeof(share_memory->msg));
    memset(share_memory->name, 0, sizeof(share_memory->name));
    pthread_mutex_unlock(&share_memory->mutex);
}

int main() {
    int shmid;
    key_t key = ftok(".", 2011);
    if ((shmid = shmget(key, sizeof(struct Message), IPC_CREAT | 0666)) < 0) {
        perror("shmget()");
        exit(1);
    }

    if ((share_memory = (struct Message *)shmat(shmid, NULL, 0)) == NULL) {
        perror("shmat()");
        exit(1);
    }

    pthread_mutexattr_t attr;
    pthread_mutexattr_init(&attr);
    pthread_mutexattr_setpshared(&attr, PTHREAD_PROCESS_SHARED);
    pthread_mutex_init(&share_memory->mutex, &attr);
    memset(share_memory, 0, sizeof(struct Message));//结构体初始化
    share_memory->pid = getpid();
    while (1) {
        signal(SIGUSR1, print);
        pause();//信号暂停,直到有信号到来为止
    }
    return 0;
}


```

## 聊天室2(pthread_cond_singal)

### client1.c

```c++
/*************************************************************************
	> File Name: client1.c
	> Author: 
	> Mail: 
	> Created Time: Tue Aug  4 09:35:30 2020
 ************************************************************************/

#include "chat.h"

struct Message *share_memory = NULL;
struct Message tmp;
int main (int argc, char **argv) {
    int opt;
    while((opt = getopt(argc, argv, "n:")) != -1) {
        switch(opt) {
            case 'n':
                strcpy(tmp.name, optarg);
                break;
            default:
                fprintf(stderr, " Usage : %s -n name!\n",argv[0]);
                break;
        }
    }

    int shmid;
    key_t key = ftok(".", 2015);
    if ((shmid = shmget(key, sizeof(struct Message), IPC_CREAT | 0666)) < 0) {
        perror("shmget()");
        exit(1);
    }
    if ((share_memory = shmat(shmid, NULL, 0)) == NULL) {
        perror("shmat");
        exit(1);
    }

    if (share_memory->pid <= 0) {
        fprintf(stderr, "Please run server first!\n");
        exit(1);
    }

    while (1) {
        scanf("%[^\n]s", tmp.msg);
        getchar();
        if (!strlen(tmp.msg)) continue;
        while (1) {
            if (!strlen(share_memory->msg)) {
                pthread_mutex_lock(&share_memory->mutex);
                break;
            }
        }
        strcpy(share_memory->name, tmp.name);
        strcpy(share_memory->msg, tmp.msg);
        pthread_mutex_unlock(&share_memory->mutex);
        pthread_cond_signal(&share_memory->cond);//当条件达成时,发送信号.
        memset(tmp.msg, 0, sizeof(tmp.msg));
        DBG(GREEN"<Dbug>"NONE " : After siganl : %s\n", share_memory->msg);
    }
}

```



### server1.c

```c++
/*************************************************************************
	> File Name: server1.c
	> Author: 
	> Mail: 
	> Created Time: Tue Aug  4 09:19:46 2020
 ************************************************************************/

#include "chat.h"

struct Message *share_memory = NULL;

int main() {
    int shmid;
    key_t key = ftok(".", 2015);
    if ((shmid = shmget(key, sizeof(struct Message), IPC_CREAT | 0666)) < 0) {
        perror("shmget()");
        exit(1);
    }

    if ((share_memory = (struct Message *)shmat(shmid, NULL, 0)) == NULL) {
        perror("shmat()");
        exit(1);
    }
    //对锁的初始化
    pthread_mutexattr_t attr;
    pthread_mutexattr_init(&attr);
    pthread_mutexattr_setpshared(&attr, PTHREAD_PROCESS_SHARED);
    pthread_mutex_init(&share_memory->mutex, &attr);
   
    //对条件变量初始化
    pthread_condattr_t cond_attr;
    pthread_condattr_init(&cond_attr);
    pthread_condattr_setpshared(&cond_attr, PTHREAD_PROCESS_SHARED);
    pthread_cond_init(&share_memory->cond, &cond_attr);

    share_memory->pid = getpid();
    while (1) {
        pthread_mutex_lock(&share_memory->mutex);
        DBG(GREEN"<Dbug>"NONE" : Before wait!\n");
        pthread_cond_wait(&share_memory->cond, &share_memory->mutex);
        DBG(GREEN"<Dbug>"NONE" : After wait!\n");
        printf("<%s> : %s\n", share_memory->name, share_memory->msg);
        memset(share_memory->msg, 0, sizeof(share_memory->msg));
        memset(share_memory->name, 0, sizeof(share_memory->name));
        pthread_mutex_unlock(&share_memory->mutex);
    }
    return 0;
}

```





# 管道

## pipe()

#include <unistd.h>

int pipe(int pipefd[2]);

#include <fcntl.h>

#include <unistd.h>

pipefd[0] => r;

pipefd[1] => w;

返回值 : 成功为0, 失败为-1

```c++
#include<stdio.h>
#include "head.h"

char buff[20];

int main (int argc, char **argv) {
    pid_t pid;
    int pipefd[2];
    pipe(pipefd);
    memset(buff, 0, sizeof(buff));
    if ((pid = fork()) < 0) {
        perror("fork()");
        exit(1);
    }

    if (pid ==  0) {
        close(pipefd[0]);
        while(1) {
            scanf("%s", buff);
            write(pipefd[1], buff, strlen(buff));
            memset(buff, 0, sizeof(buff));
        }
    } else {
        close(pipefd[1]);
        while(1) {
            read(pipefd[0], buff, sizeof(buff));
            printf("%s\n", buff);
            memset(buff, 0, sizeof(buff));
        }
    }
    return 0;
}

```







## popen()

FILE *popen(const char *command, const char *type);

int pclose(FILE *stream);

popen()函数通过创建一个管道，调用fork()产生一个子进程，执行一个shell以运行命令来开启一个进程。这个管道必须由pclose()函数关闭，而不是fclose()函数。pclose()函数关闭标准I/O流，等待命令执行结束，然后返回shell的终止状态。如果shell不能被执行，则pclose()返回的终止状态与shell已执行exit一样。

　　type参数只能是读或者写中的一种，得到的返回值（标准I/O流）也具有和type相应的只读或只写类型。如果type是"r"则文件指针连接到command的标准输出；如果type是"w"则文件指针连接到command的标准输入。

　　command参数是一个指向以NULL结束的shell命令字符串的指针。这行命令将被传到bin/sh并使用-c标志，shell将执行这个命令。

　　popen()的返回值是个标准I/O流，必须由pclose来终止。前面提到这个流是单向的（只能用于读或写）。向这个流写内容相当于写入该命令的标准输入，命令的标准输出和调用popen()的进程相同；与之相反的，从流中读数据相当于读取命令的标准输出，命令的标准输入和调用popen()的进程相同。

### 返回值

　　如果调用fork()或pipe()失败，或者不能分配内存将返回NULL，否则返回标准I/O流。popen()没有为内存分配失败设置errno值。如果调用fork()或pipe()时出现错误，errno被设为相应的错误类型。如果type参数不合法，errno将返回EINVAL。



，

## fileno()函数



功  能：把文件流指针转换成文件描述符
相关函数：open, fopen
表头文件：#include <stdio.h>
定义函数：int fileno(FILE *stream)
函数说明：fileno()用来取得参数stream指定的文件流所使用的文件描述词
返回值 ：返回和stream文件流对应的文件描述符。如果失败，返回-1。
范例：
\#include <stdio.h>
main()
{
   FILE  *fp;
   int  fd;
   fp = fopen("/etc/passwd", "r");
   fd = fileno(fp);
   printf("fd = %d\n", fd);
   fclose(fp);
}

  文件描述词是Linux编程中的一个术语。当一个文件打开后，系统会分配一部分资源来保存该文件的信息，以后对文件的操作就可以直接引用该部分资源了。文件描述词可以认为是该部分资源的一个索引，在打开文件时返回。在使用fcntl函数对文件的一些属性进行设置时就需要一个文件描述词参数。
  以前知道，当程序执行时，就已经有三个文件流打开了，它们分别是标准输入stdin，标准输出stdout和标准错误输出stderr。和流式文件相对应的是，也有三个文件描述符被预先打开，它们分别是0，1，2，代表标准输入、标准输出和标准错误输出。
  需要指出的是，上面的流式文件输入、输出和文件描述符的输入输出方式不能混用，否则会造成混乱。

## waitpid()



# IO阻塞

$\color{red}{阻塞（Block)}$这个概念。当进程调用一个阻塞的系统函数时，该进程被置于睡眠（Sleep）状态，这时内核调度其它进程运行，直到该进程等待的事件发生了（比如网络上接收到数据包，或者调用sleep指定的睡眠时间到了）它才有可能继续运行。与**睡眠状态**相对的是**运行（*****\*Running\**\**）状态\****，在Linux内核中，处于运行状态的进程分为两种情况：

阻塞ＩＯ是要等待通知，　非阻塞ＩＯ是不断询问

$\color{red}{非阻塞IO}$

应用进程通过 recvfrom 调用不停的去和内核交互，直到内核准备好数据。如果没有准备好，内核会返回error，应用进程在得到error后，过一段时间再发送recvfrom请求。在两次发送请求的时间段，进程可以先做别的事情。

## IOCTL(2)

头文件: #include <sys/ioctl.h>

函数：int ioctl(int fd, unsigned long request, …);

​		fd : 打开的文件描述符.

​		request : <sys/ioctl.h>已定义各种request code;

​		FIONBIO非阻塞IO 

unsignd long ul = 1\0; // 1为非阻塞，0为阻塞

ioctl(fd, FIONBIO, &ul);		

返回值: fail : -1;

## FCNTL

| 头文件   | 头文件: ＃include <unistd.h><br/># include <fcntl.h>         |
| -------- | ------------------------------------------------------------ |
| 函数定义 | int fcntl(int fd, int cmd, …/* arg */);                      |
| 函数声明 | fcntl()是对文件描述符的操作，具体操作cmd来决定.第三个参数是否需要由cmd来决定．<br/> 大多数情况我们用int 来定义要求．我们用arg或void 来定义参数<br/>flags定义IO类型．<br/>F_GETFD(void) 获取flag,无参数<br/>F_SETFD(int);通过参数arg给flags赋值.<br/>获取文件状态的flag<br/>F_GETFL(void)  获取文件的状态和权限的flag,参数无<br/>F_SETFL(int) 通过参数arg设置文件状态.<br/>open的flag可通过flag 来设置．<br/> |
| 返回值   | 出错－１                                                     |





````c++
int make_non_block (int fd) {
    int flag;
    if ((flag = fcntl(fd, F_GETFL)) < 0) {//F_GETFL获取文件的状态和权限的flag
        return -1;
    }//获取原来的flag
    flag |= O_NONBLOCK;//给flag蒸饺阻塞
    fcntl(fd, F_SETFL, flag);//把新的flag设置给fd文件
    return 0;
}

int make_block(int fd) {
    int flag;
    if ((flag = fcntl(fd, F_GETFL)) < 0) {
        return -1;
    }
    flag &= ~O_NONBLOCK;
    fcntl(fd, F_SETFL, flag);
    return 0;
}


````







# IO的多路复用

## select 同步I/O复用



| 头文件   | #include <sys/time.h><br/>#include <sys/types.h><br/>#include <unistd.h> |
| -------- | ------------------------------------------------------------ |
| 函数定义 | int select(int nfds,  fd_set *readfds,  fd_set *writefds,  fd_set *exceptfds, struct timeval *timeout); |
| 函数声明 | select（）和pselect（）允许程序监视多个文件描述符，直到一个或多个文件描述符“准备好”进行某类I/O操作（例如，可能的输入）。如果可以执行相应的I/O操作（例如，不阻塞地读取（2），或足够小的写入操作(2)),则认为文件描述符准备就绪。<br/>          select（）只能监视小于FD_SETSIZE的文件描述符编号；poll（2）没有此限制。<br/><br/>参数: **nfds:**     是一个整数值，是指集合中所有文件描述符的范围，即所有文件描述符的最大值加1，不能错！<br/>  参数: **fd_set* readfd**s:是指向fd_set结构的指针，这个集合中应该包括文件描述符，我们是要监视这些文件描述符的读变化的，即我们关心是否可以从这些文件中读取数据了，如果这个集合中有一个文件可读，select就会返回一个大于0的值，表示有文件可读，如果没有可读的文件，则根据timeout参数再判断是否超时，若超出timeout的时间，select返回0，若发生错误返回负值。可以传入NULL值，表示不关心任何文件的读变化。 <br/>  **fd_set* writefds : **是指向fd_set结构的指针，这个集合中应该包括文件描述符，我们是要监视这些文件描述符的写变化的，即我们关心是否可以向这些文件中写入数据了，如果这个集合中有一个文件可写，select就会返回一个大于0的值，表示有文件可写，如果没有可写的文件，则根据timeout再判断是否超时，若超出timeout的时间，select返回0，若发生错误返回负值。可以传入NULL值，表示不关心任何文件的写变化。<br/> **fd_set* errorfds**同上面两个参数的意图，用来监视文件错误异常。<br/>  struct timeval* timeout是select的超时时间，这个参数至关重要，它可以使select处于三种状态。<br/>＜＞**fd_set** : 提供了四个宏来操作集合。**FD_ZERO（）**清除集合。**FD_SET（）**和**FD_CLR（）**分别在集合中**添加**和**移除**给定的文件描述符。**FD_ISSET（）**测试文件描述符是否是集合的一部分；在select（）返回后，这很有用。<br/>第一：若将**NULL**以形参传入，即不传入时间结构，就是将select置于**NULL**状态，一定等到监视文件描述符集合中某个文件描述符发生变化为止；<br/> 第二：若将时间值设为**0秒0毫秒**，就变成一个纯粹的**非阻塞**函数，不管文件描述符是否有变化，都立刻返回继续执行，文件无变化返回0，有变化返回一个正值；<br/> 第三：timeout的值**大于0**，这就是**等待的超时时间**，即select在timeout时间内阻塞，超时时间之内有事件到来就返回了，否则在超时后不管怎样一定返回，返回值同上述。<br/> |
| 返回值   | 成功时，select（）和pselect（）返回三个返回描述符集中包含的文件描述符的数量（即readfds、writefds、exceptfds中设置的位的总数），如果超时在任何有趣的事情发生之前过期，则可能为零。出错时，返回-1，并设置errno以指示错误；文件描述符集未被修改，超时将变为未定义。 |



 ```c++
The timeout
       The time structures involved are defined in <sys/time.h> and look like

           struct timeval {
               long    tv_sec;         /* seconds */
               long    tv_usec;        /* microseconds */
           };

       and

           struct timespec {
               long    tv_sec;         /* seconds */
               long    tv_nsec;        /* nanoseconds */
           };


 ```



```c++
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <sys/time.h>
#include <sys/types.h>
#include <unistd.h>
int main(void) {
    fd_set rfds;
    struct timeval tv;
    int retval;

    /* Watch stdin (fd 0) to see when it has input. */
    
    FD_ZERO(&rfds);//清空文件描述符集　void FD_ZERO(fd_set *set);
    FD_SET(0, &rfds);//把标准输入文件的异常信息注册到文件描述符集中
    
    /* Wait up to five seconds.*/
    //设置等待时间，等待５秒
    
    tv.tv_sec = 5;//秒
    tv.tv_usec = 0;//微秒
    retval = select(1, &rfds, NULL, NULL, &tv); 
    
    /* Don't rely on the value of tv now! */
    
    if (retval == -1) {
        perror("select()");
    } else if (retval){
        printf("Data is available now.\n");
        char buffer[1024];
        ssize_t re, we;
        while ((re = read(0, buffer, strlen(buffer))) > 0) {
            printf("%s", buffer);
        }
        printf("\n");
    /* FD_ISSET(0, &rfds) will be true. */   
    } else {
        printf("No data within five seconds.\n");
    }
    exit(EXIT_SUCCESS);
    return 0;
}


```



#　IO多路复用之epoll

​	#inlude<sys/epoll.h>

​	所述epoll的 API执行类似的任务poll(2), 监视多个 文件描述符，以查看是否可以在其中任何一个上进行I / O。该epoll的API可以用作边沿触发或水平触发 界面并可以很好地扩展到大量监视文件 描述符。提供了以下系统调用来创建和管理epoll 实例：

​	· epoll_create（2）创建一个新的epoll实例并返回一个文件引用该实例的描述符。（更近epoll_create1（2）扩展的功能epoll_create（2） ）

​	·特别文件描述符兴趣，然后通过注册epoll_ctl（2） ，增加了项目的利益列表epoll的 实例。
       · epoll_wait（2）等待I / O事件，如果当前没有可用的事件，则阻塞调用线程。（这个系统调用可以被认为是从的准备列表读取项目epoll的 实例。）电平触发和边沿触发 的epoll的





## epoll_create()  :  打开epoll文件描述符



| 头文件   | #include <sys/epoll.h>                                       |
| -------- | ------------------------------------------------------------ |
| 函数定义 | int epoll_create(int size);                                  |
| 函数声明 | epoll_create（）创建一个新的epoll（7）实例。从Linux 2.6.8开始,该尺寸参数将被忽略，但必须大于零;<br/>epoll_create（）返回引用新epoll的文件描述符实例。该文件描述符用于所有后续调用进入epoll界面。当不再需要时，文件描述符epoll_create（）返回的值应使用close（2）关闭。什么时候 所有引用epoll实例的文件描述符都已关闭， 内核销毁实例并释放关联的重用资源。 |
| 返回值   | 成功执行后，这些系统调用将返回文件描述符（非负整数）。错误时，返回-1，并将errno设置为指出错误。 |

​​

## epoll_ctl() : epoll文件描述符的控制接口



**该函数用于控制某个epoll文件描述符上的事件，可以注册事件，修改事件，删除事件。**

| 头文件   | #include <sys / epoll.h>                                     |
| -------- | ------------------------------------------------------------ |
| 函数定义 | int epoll_ctl（int epfd ，int op ，int fd ，struct epoll_event * event ）; |
| 函数声明 | **epfd：由 epoll_create 生成的epoll专用的文件描述符；**<br/> **op：要进行的操作例如注册事件，可能的取值EPOLL_CTL_ADD 注册、EPOLL_CTL_MOD 修 改、EPOLL_CTL_DEL 删除**(该事件参数被忽略，可以为NULL)<br/> **fd：关联的文件描述符；**<br/>epoll_event是要监听的事件 |
| 返回值   | 成功时，epoll_ctl（）返回零。发生错误时， epoll_ctl（）返回-1，并正确设置errn |



该结构epoll_event定义为：

```c++
    typedef union epoll_data //联合体
               void* ptr;
               int fd;
               uint32_t u32;
               uint64_t u64;
           } epoll_data_t;

           struct epoll_event {
               uint32_t events；/ * Epoll事件* /
               epoll_data_t data；/ *用户数据变量* /
           };
```

常用的事务类型:
EPOLLIN ：默示对应的文件描述符可以读；
EPOLLOUT：默示对应的文件描述符可以写；
EPOLLPRI：默示对应的文件描述符有紧急的数据可读
EPOLLERR：默示对应的文件描述符产生错误；
EPOLLHUP：默示对应的文件描述符被挂断；
EPOLLET:    将EPOLL设为边缘触发(Edge Triggered)模式，这是相对于水平触发(Level Triggered)来说的。只做一次

  EPOLLONESHOT：    只监听一次事件，当监听完这次事件之后，如果还需要继续监听这个socket的话，需要再次把这个socket加入到EPOLL队列里。

```c++
struct epoll_event ev;
//设置与要处理的事件相关的文件描述符
ev.data.fd=listenfd;
//设置要处理的事件类型
ev.events=EPOLLIN|EPOLLET;
//注册epoll事件
epoll_ctl(epfd,EPOLL_CTL_ADD,listenfd,&ev);
```



   

##  EPOLL_WAIT()-等待在epoll的文件的I / O事件的描述符

| 头文件   | #include <sys / epoll.h>                                     |
| -------- | ------------------------------------------------------------ |
| 函数定义 | int epoll_wait（int epfd ，struct epoll_event * events ，int maxevents ，int timeout ）; |
| 函数声明 | 在epoll_wait以获取事件（）系统调用等待epoll的（7）例如由文件描述符称为epfd的。指出缓冲区通过到事件被用于从约就绪表中返回信息的兴趣列表文件的描述有一些事件提供。截至maxevents被返epoll_wait（）。该maxevents参数必须大于零。 的超时参数指定的毫秒数 epoll_wait（）将阻止。时间是根CLOCK_MONOTONIC时钟。<br/>对epoll_wait（）的调用将一直阻塞，直到：<br/>文件描述符传递事件；<br/>·呼叫被信号处理程序中断；或<br/>·超时到期。<br/>请注意，超时间隔将四舍五入到系统时钟 粒度，并且内核调度延迟意味着阻塞 间隔可能会少量溢出。将超时指定为-1 会导致epoll_wait（）无限期地阻塞，而将超时指定 为零则导致epoll_wait（）立即返回，即使没有可用的事件也是如此。该结构epoll_event定义为：<br/> |
| 返回值   | 成功时，epoll_wait（）返回为请求的I / O准备就绪的文件描述符的**数量；**如果在请求的超时毫秒内没有文件描述符准备就绪，则返回零。发生错误时，epoll_wait（）返回-1并正确设置errno。 |

​         

```c++
   typedef union epoll_data { 
                  void * ptr; 
                  int fd; 
                  uint32_t u32; 
                  uint64_t u64; 
              } epoll_data_t; 

              struct epoll_event { 
                  uint32_t events; / * Epoll事件* / 
                  epoll_data_t数据；/ *用户数据变量* / 
              }; 每个返回的epoll_event结构 的数据字段包含与最近一次对epoll_ctl（2）调用中指定的数据相同的数据

       （EPOLL_CTL_ADD，EPOLL_CTL_MOD
```



##　范例

```c++
#define MAX_EVENTS 10//最多监测数目
    struct epoll_event ev, events[MAX_EVENTS];//监测
    int listen_sock, conn_sock, nfds, epollfd;

    /* Code to set up listening socket, 'listen_sock',(socket(), bind(), listen()) omitted */

    epollfd = epoll_create(0);//创建监听
    if (epollfd == -1) {
        perror("epoll_create1");
        exit(EXIT_FAILURE);
    }

    ev.events = EPOLLIN;　//可读
    ev.data.fd = listen_sock;　//关联的文件描述符，　监听的目标
    //给listen_sock注册可读事件
	//将listen_sock加入监听范围内, 监听listen_sock是否可读．
    if (epoll_ctl(epollfd, EPOLL_CTL_ADD, listen_sock, &ev) == -1) {
        perror("epoll_ctl: listen_sock");
        exit(EXIT_FAILURE);
    }

    for (;;) {
        nfds = epoll_wait(epollfd, events, MAX_EVENTS, -1);//等待监听事件的触发，　没有事件一直阻塞
        if (nfds == -1) {
        	perror("epoll_wait");
        	exit(EXIT_FAILURE);
        }

        for (n = 0; n < nfds; ++n) {
            if (events[n].data.fd == listen_sock) {
                conn_sock = accept(listen_sock, (struct sockaddr *) &addr, &addrlen);
                if (conn_sock == -1) {
                    perror("accept");
                    exit(EXIT_FAILURE);
                }
                setnonblocking(conn_sock);　//非阻塞操作
                ev.events = EPOLLIN | EPOLLET;
                ev.data.fd = conn_sock;
                if (epoll_ctl(epollfd, EPOLL_CTL_ADD, conn_sock, &ev) == -1) {
                    perror("epoll_ctl: conn_sock");
                    exit(EXIT_FAILURE);
                }
            }else {
                do_use_fd(events[n].data.fd);
            }
        }
    }

```





# 服务端与客户端

## socket(建立通信的端口，并返回引用该端口的文件描述符．)

| 头文件   | #include <sys/types.h> <br/>#include <sys/socket.h>          |
| -------- | ------------------------------------------------------------ |
| 函数定义 | int socket(int domain, int type, int protocol);              |
| 函数声明 | 参数：域domain: AF_INET,AF_INEF6,AF_LOCAL,AF_ROUTE<br/>类型type：SOCK_STREAM, SOCK_DGRAM,SOCK_PACKET,SOCK_SEQPACKET<br>协议protocol:IPPROTO_TCP, IPPROTO_UDP, IPPROTO_TIPC;一般为０ |
| 返回值   | 对于新的套接字，则返回一个新的描述符。出错时，返回-1，并适当设置errno。 |





## bind()绑定ip和端口

| 头文件   | #include <sys/types.h><br/>#include <sys/socket.h>           |
| -------- | ------------------------------------------------------------ |
| 函数定义 | int bind(int sockfd, const struct sockaddr *addr*, socketlen_t addrlen ); |
| 函数声明 | sockfd是调用socket返回的文件描述符<br/>addr是指向数据结构struct sockaddr 的指针，　它保存你的地址（即端口和IP地址）信息<br/>addrlen设置为sizeof(struct sockaddr) |
| 返回值   | 出错-1，无错为０                                             |

socket 的相关结构体

```c++
struct sockaddr{

​	sa_family sin_family;

​	char sa_data[14];

};
```

```c++
struct sockaddr_in {

​	sa_family_t sin_family;　//协议族

​	in_port_t sin_port;    //端口

​	struct in_addr sin_addr;　//地址

}
```

```c++
struct in_addr {

​	unit32_t  s_addr;

};
```

用struct  sockaddr_in需要强转成struct sockaddr；

## 本地与网络的转换

#include <arpa/inet.h>

uint32_t  htonl(uint32_t hostlong); //本地字节序转换成网络字节序的长整形

uint32_t  htons(uint32_t hostshort); //本地字节序转换成网络字节序的短整形

uint32_t  ntohl(uint32_t hostlong); //网络字节序转换成本地字节序的长整形

uint32_t  ntohs(uint32_t hostshort); //网络字节序转换成本地字节序的短整形

in_addr_t inet_addr (const char *ip);

char *inet_ntoa(struct in_addr in);

网络字节序和本地字节序不同，　因此要转换．

## linsten() 监听socket,将主动套阶子变被动套阶字；

| 头文件                                    | #include <sys/types.h><br/>#include <sys/socket.h> |
| ----------------------------------------- | -------------------------------------------------- |
| 函数定义                                  | int listen(int sockfd, int backlog);               |
| 函数声明                                  | sockfd是掉用socket()返回的套接字文件描述符．<br/>  |
| backlog是在进入队列中允许的连接数目返回值 | 出错－１，设errno                                  |



## accept()

#include <sys/types.h>

#include <sys/socket.h>

int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);

accept()用来从sockfd上返回一个新的链接；

1.第一个参数sockfd必须是经由socket(),bind(),listen()函数处理后的socket;

2.第二个参数是一个地址，将保存对端地址到该地址中

３.第三个参数是地址长度的地址．

返回值:如果成功返回一个新的sockfd，原来的sockfd依然可以用来accept,如果失败，则返回-1;

## connect() (用于客户端建立tcp连接)

| 头文件   | #include <sys/types.h><br/>#include <sys/socket.h>           |
| -------- | ------------------------------------------------------------ |
| 函数定义 | int connet(int sockfd, const struct sockaddr *addr, socklen_t addrlen); |
| 函数声明 |                                                              |
| 返回值   | 错误返回-1;否则返回０；                                      |







## send()发送数据

```c++
 #include <sys / types.h> 
 #include <sys / socket.h>
       ssize_t send（int sockfd ，const void * buf ，size_t len ，int flags ）;
       ssize_t sendto（int sockfd ，const void * buf ，size_t len ，int flags ，const struct sockaddr * dest_addr ，socklen_t addrlen ）;
       ssize_t sendmsg（int sockfd ，const struct msghdr * msg ，int flags ）;
```

flags可以设置为0;

sendto主要用在UDP通信中

dest_addr为远端要通信的网络地址

返回值：实际读入缓冲的数据的字节数．在出错的时候返回-1;同时设置errno

## recv()

```c++
   #include <sys / types.h> 
       #include <sys / socket.h>

       ssize_t recv（int sockfd ，void * buf ，size_t len ，int flags ）;

       ssize_t recvfrom（int sockfd ，void * buf ，size_t len ，int flags ，
                        struct sockaddr * src_addr ，socklen_t * addrlen ）;

       ssize_t recvmsg（int sockfd ，struct msghdr * msg ，int flags ）;
```

sockfd是要读的套接字描述符

flags可设置为０

## close()

#include <unistd.h>

int close(int fd);

## 服务端的而建立

```c++
int socket_create(int port) {
    int sockfd;
    if ((sockfd = socket(AF_INET, SOCK_STREAM, 0)) < 0) { //int socket(int domain, int type, int protocal);
        return -1;
    }
    //重启地址
    int val = 1;
    if (setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR,(const char*)&val, sizeof(int)) < 0) {
        return -1;
    }
    struct sockaddr_in server;//创建表单名server;
    server.sin_family = AF_INET;
    server.sin_port = htons(port);//本地字节序转换成网络字节序的短整形
    server.sin_addr.s_addr = inet_addr("0.0.0.0");//所有的都要
    if (bind(sockfd, (struct sockaddr *)&server, sizeof(server)) < 0) {
        return -1;
    }

    if (listen(sockfd, 10) < 0) {
        return -1;
    }
    return sockfd;
}

```

```
INADDR_ANY
转换过来就是0.0.0.0，泛指本机的意思，也就是表示本机的所有IP，因为有些机子不止一块网卡，多网卡的情况下，这个就表示所有网卡ip地址的意思。
```

## 客户端的建立

```c++
int socket_connect(char *ip, int port){
    int sockfd;//创建端口名
    if ((sockfd = socket(AF_INET, SOCK_STREAM, 0)) < 0) {
        return -1;
    }

    struct sockaddr_in server;
    server.sin_family = AF_INET;
    server.sin_port = htons(port);
    server.sin_addr.s_addr = inet_addr(ip);
    if (connect(sockfd, (struct sockaddr *)&server, sizeof(server)) < 0) {
        return -1;
    }
    return sockfd;
}

```



## recvfrom()



| 头文件   | #include <sys/types.h><br/>#include <sys/socket.h>           |
| -------- | ------------------------------------------------------------ |
| 函数定义 | ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags,struct sockaddr *src_addr, socklen_t *addrlen); |
| 函数声明 | s：标识一个已连接套接口的描述字。 <br/>buf：接收数据缓冲区。<br/>len：缓冲区长度<br/>flags：调用操作方式。<br/>from：（可选）指针，指向装有源地址的缓冲区。<br/>fromlen：（可选）指针，指向from缓冲区长度值。 |
| 返回值   | 若无错误发生，recvfrom()返回读入的字节数。如果连接已中止，返回-1。否则的话，返回SOCKET_ERROR错误，应用程序可通过WSAGetLastError()获取相应错误代码。当流套接字对等方执行有序关闭时，返回值将为0（传统的“文件结束”返回）。不同域（如UNIX和Internet域）中的数据报套接字允许零长度的数据报。当接收到这样的数据报时，返回值为0。如果从流套接字接收的请求字节数为0，则也可能返回值0 |

## sendto()

| 头文件   | #include <sys/types.h>   #include <sys/socket.h>             |
| -------- | ------------------------------------------------------------ |
| 函数定义 | int sendto(int s, const void * msg, int len, unsigned int flags, const struct sockaddr * to, int tolen); |
| 函数声明 | sendto() 用来将数据由指定的socket 传给对方主机. 参数s 为已建好连线的socket, 如果利用UDP协议则不需经过连线操作. 参数msg 指向欲连线的数据内容, 参数flags 一般设0, 详细描述请参考send(). 参数to 用来指定欲传送的网络地址, 结构sockaddr 请参考bind(). 参数tolen 为sockaddr 的结果长度. |
| 返回值   | 成功则返回实际传送出去的字符数, 失败返回－1, 错误原因存于errno 中. |



## TCP.UDP

传输控制协议面向连接，可靠的数据传输协议.

IP尽力而为地服务，可能会丢失．

## 虚拟空间

### .物理内存空间 和 虚拟内存空间

物理内存大小组成的地址空间就叫物理内存空间。物理内存空间表示的是实实在在的RAM物理内存，其地址空间可以看成一个由 M 个连续的字节大小的单元组成的数组，每个字节都有一个唯一的物理地址。【存储单元，也就是每个字节都有其地址，cpu进行访问的时候需要知道其地址。M就是RAM的大小】

虚拟内存大小组成的地址空间就叫虚拟内存空间。跟物理内存一样，也是有地址空间的，用地址标识哪个内存位置，也看成一个连续的字节大小的单元组成的数组。【**虚拟内存空间实际上并不存在的，需要的只是虚拟内存空间到物理内存空间的映射关系的一种数据结构。】**

上面说的数组的大小，就是地址空间的长度。即地址空间是一个抽象的概念，可以想象成一个很大的数组，每个数组的元素是一个字节，而这个数组的大小就是由地址空间的地址长度决定。一般画图也是这么画的。

16G的物理内存条，具有0~0x3FFFFFFFF（16G）的地址长度的寻址能力。【**cpu的地址总线位宽**决定了可以直接进行寻址**物理内存空间**】

4G虚拟内存，具有0~0xFFFFFFFF的地址长度的寻址能力。

在一个系统中，**物理内存空间只有一个，但是虚拟内存空间有很多个（运行着多个进程）**。每个虚拟内存空间都有必须有一个映射关系对应于物理内存。【在进程启动的时候会建议一个映射关系，在运行中维护这个关系】

对于一般程序而言，虚拟内存空间中的很大部分的都是未使用的，【虚拟内存一般是4G】

每个虚拟内存空间往往只能映射到很少一部分物理空间上。每个**物理页（**将整个**物理空间**划分成**多个大小相等的页）**通常也只会被映射到一个虚拟地址空间中。如果有一个**物理页**被映射到**多个虚拟地址空间**中，那么这些地址空间将共享此页面，如果在一个虚拟地址空间改写了此页面的数据，这在其他的虚拟地址空间也可以看到变化。

### .虚拟内存的地址空间划分

在 Windows 系统下，虚拟地址空间被分成了 4 部分： NULL 指针区、用户区、 64KB 禁入区、内核区。

**用户区**每个进程私有使用的，大约 2GB 左右 ( 最大可以调整到 3GB，3GB模式) ，称为用户地址空间。用户区存放的是**程序代码和数据\*,\* 堆\*,\* 共享库\*,\* 栈**。

**内核区**是**所有进程共享**的**，**为 2GB ，称为**系统地址空间**。

**内核区**保存的是**系统线程调度**、**内存管理**、**设备驱动**等数据，这部分数据供**所有的进程共享以及操作系统的使用**——程序在运行的时候处于**操作系统**的监管下，监管**进程的虚拟空间**，当进程进行**非法访问**时强制结束程序。（进程只能使用操作系统非陪给进程的虚拟空间。错误提示**“进程因非法操作需要关闭”**就是访问了未经允许的地址。）

上述的2GB+2GB称为2GB模式，是在默认的windows配置下。可以修改windows配置，可以设置3GB用户地址空间+1GB的系统地址空间，称为3GB模式。

### 进程的虚拟内存空间的划分：

Linux进程的虚拟内存区域分为：代码区、只读常量区、全局区、BSS段、堆区、栈区

代码区：存储功能代码，函数名所在的区域

只读常量区：存放字符串常量，以及const修饰的全局变量

全局区/数据区：存放已经初始化的全局变量和已经初始化用static修饰的局部变量

BSS段：存放没有初始化的全局变量和未初始化静态局部变量，该区域会在main函数执行前进行自动清零

堆区：使用malloc/new free/delete函数处理的内存，该区域的内存需要程序员手动申请和释放

栈区：存放局部变量（包括函数的形参），const修饰的局部变量以及块变量，该区域的内存由操作系统负责分配和回收，程序员尽管放心使用

注意：栈区和堆区之间并没有严格分割线，可以进行微调，并且堆区分配一般从低地址到高地址分配，而栈区分配一般从高地址到低地址分配

## 什么是内核态，什么是用户态．

 一般现代CPU都有几种不同的指令执行级别。

在高执行级别下，代码可以执行特权指令，访问任意的物理地址，这种CPU执行级别就对应着内核态。

而在相应的低级别执行状态下，代码的掌控范围会受到限制。只能在对应级别允许的范围内活动。

举例：

intel x86 CPU有四种不同的执行级别0-3，linux只使用了其中的0级和3级分别来表示内核态和用户态。



当一个任务（进程）执行系统调用而陷入内核代码中执行时，我们就称进程处于内核运行态（或简称为内核态）。此时处理器处于特权级最高的（0级）内核 代码中执行。当进程处于内核态时，执行的内核代码会使用当前进程的内核栈。每个进程都有自己的内核栈。当进程在执行用户自己的代码时，则称其处于用户运行 态（用户态）。即此时处理器在特权级最低的（3级）用户代码中运行。当正在执行用户程序而突然被中断程序中断时，此时用户程序也可以象征性地称为处于进程 的内核态。因为中断处理程序将使用当前进程的内核栈。这与处于内核态的进程的状态有些类似。

# select(程序监视多个文件描述符)

==头文件==:#include <sys/select.h>

==函数==:int select（int nfds ，fd_set * readfds ，fd_set * writefds ，fd_set * exceptfds ，struct timeval * timeout ）;

void FD_CLR（int fd ，fd_set * set ）; 
       int FD_ISSET（int fd ，fd_set * set ）; 
       void FD_SET（int fd ，fd_set * set ）; 
       void FD_ZERO（fd_set * set ）;

int pselect（int nfds ，fd_set * readfds ，fd_set * writefds ，  fd_set * exceptfds ，const struct timespec *timeout, const sigset_t * sigmask ）;

 pselect（）：_ POSIX_C_SOURCE> = 200112L

select函数共有5个==参数==:

`maxfd`：监视对象文件描述符数量。

`readset`：将所有关注“是否存在待读取数据”的文件描述符注册到fd_set变量，并传递其地址值。
`		writeset`： 将所有关注“是否可传输无阻塞数据”的文件描述符注册到fd_set变量，并传递其地址值。
`		exceptset`：将所有关注“是否发生异常”的文件描述符注册到fd_set变量，并传递其地址值。

`timeout`：调用select后，为防止陷入无限阻塞状态，传递超时信息。
==返回值==：错误返回-1，并设置errno,超时返回0。当关注的事件返回时，返回大于0的值，该值是发生事件的文件描述符数,即文件描述符集包含的文件描述符的数量．

==功能==：调用select函数后查看结果

如果select返回值大于0，说明文件描述符发生了变化。

关于文件描述符变化：
**文件描述符变化是指监视的文件描述符中发生了相应的监视事件。**
例如通过select的第二个参数传递的集合中存在需要读取数据的描述符时，就意味着文件描述符发生变化。

怎样获知哪些文件描述符发生了变化？向select函数的第二到第四个参数传递的fd_set变量中将产生变化，如下图：
![这里写图片描述](https://img-blog.csdn.net/20180401144107192?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hteHoybm4=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
select函数调用完成后，向其传递的fd_set变量中将发生变化。原来为1的所有位均变为0，但发生变化的文件描述符对应位除外。因此，可以认为值为1的位置上的文件描述符发生了变化。

# mmap

## NAME     

https://man7.org/linux/man-pages/man2/mmap.2.html

mmap，munmap-将文件或设备映射或取消映射到内存中

## 大纲     

```c++
       #include <sys / mman.h>
       void * mmap（void * addr ，size_t length ，int prot ，int 标志，  int fd ，off_t offset ）; 
       int munmap（void * addr ，size_t length ）;
```

 

##　说明

**参数**

start：映射区的开始地址

length：映射区的长度

prot：期望的内存保护标志，不能与文件的打开模式冲突。是以下的某个值，可以通过or运算合理地组合在一起

PROT_EXEC：页内容可以被执行

PROT_READ：页内容可以被读取

PROT_WRITE：页可以被写入

PROT_NONE：页不可访问

flags：指定映射对象的类型，映射选项和映射页是否可以共享。它的值可以是一个或者多个以下位的组合体:

MAP_FIXED //使用指定的映射起始地址，如果由start和len参数指定的内存区重叠于现存的映射空间，重叠部分将会被丢弃。如果指定的起始地址不可用，操作将会失败。并且起始地址必须落在页的边界上。
**MAP_SHARED** //与其它所有映射这个对象的进程共享映射空间。对共享区的写入，相当于输出到文件。直到msync()或者munmap()被调用，文件实际上不会被更新。
MAP_PRIVATE //建立一个写入时拷贝的私有映射。内存区域的写入不会影响到原文件。这个标志和以上标志是互斥的，只能使用其中一个。
MAP_DENYWRITE //这个标志被忽略。
MAP_EXECUTABLE //同上
MAP_NORESERVE //不要为这个映射保留交换空间。当交换空间被保留，对映射区修改的可能会得到保证。当交换空间不被保留，同时内存不足，对映射区的修改会引起段违例信号。
MAP_LOCKED //锁定映射区的页面，从而防止页面被交换出内存。
MAP_GROWSDOWN //用于堆栈，告诉内核VM系统，映射区可以向下扩展。
MAP_ANONYMOUS //匿名映射，映射区不与任何文件关联。
MAP_ANON //MAP_ANONYMOUS的别称，不再被使用。
MAP_FILE //兼容标志，被忽略。
MAP_32BIT //将映射区放在进程地址空间的低2GB，MAP_FIXED指定时会被忽略。当前这个标志只在x86-64平台上得到支持。
MAP_POPULATE //为文件映射通过预读的方式准备好页表。随后对映射区的访问不会被页违例阻塞。
MAP_NONBLOCK //仅和MAP_POPULATE一起使用时才有意义。不执行预读，只为已存在于内存中的页面建立页表入口。

fd：有效的文件描述词。如果MAP_ANONYMOUS被设定，为了兼容问题，其值应为-1

offset：被映射对象内容的起点

返回值

成功时，mmap（）返回一个指向映射区域的指针。错误时，
该值MAP_FAILED（即，（void*）-1）被返回，error被
 设置为显示错误的原因。

​       如果成功，则munmap（）返回0。如果失败，则返回-1，并且将errno 设置为指示错误的原因（可能为EINVAL）。





## statfs：磁盘内存的获取



| 头文件   | #include <sys/vfs.h>    /* or <sys/statfs.h> */              |
| -------- | ------------------------------------------------------------ |
| 函数定义 | int statfs(const char *path, struct statfs *buf);<br/>int fstatfs(int fd, struct statfs *buf); |
| 函数说明 | statfs（）系统调用返回有关已装入文件系统的信息。path是装入的文件系统中任何文件的路径名。<br/>buf是一个指向statfs结构的指针，其定义大致如下：<br/>struct statfs{<br/>_fsword_t f_type；/*文件系统的类型（见下文）*/<br/>fsword_t f_bsize；/*最佳传输块大小*/<br/>fsblkcnt_t  f_blocks；/*文件系统中的总数据块*/<br/>fsblkcnt_t f_bfree；/*文件系统中的可用块*/<br/>fsblkcnt_t f_bavail；/*非特权用户可用的可用块*/<br/>fsfilcnt_t f_files；/*文件系统中的文件节点总数*/<br/>fsfilcnt_t f_ffree；/*文件系统中的可用文件节点*/<br/>fsid_t f_fsid；/*文件系统ID*/<br/>__ fsword_t f_namelen；/*文件名的最大长度*/<br/> __ fsword_t f_frsize；/*碎片大小（从Linux 2.6.6开始）*/<br/> __ fsword_t f__标志；/*文件系统的装载标志（从Linux 2.6.36开始）*/<br/> fsword_t f_spare[xxx]；/*为将来使用保留的填充字节*/<br/>} |
| 返回值   | 成功返回0， 失败返回-1                                       |



## setmntent() : 打开文件系统描述文件的文件名，并且返回可以被使用的文件指针getmntent().

## getmntent() :函数读取文件系统的下一行来自文件流的描述文件并返回指向结构的指针（即循环读取文件）



## endmntent：关闭流和与其相关联的文件系统描述文件。



| 头文件   | #include <stdio.h><br/>#include <mntent.h>                   |
| -------- | ------------------------------------------------------------ |
| 函数定义 | FILE * setmntent（const char * filename ，const char * type ）;<br/>struct mntent *getmntent(FILE *stream);<br/> int endmntent（FILE * fp ）; |
| 函数声明 | setmntent: filename  要打开的文件名字 type      表示打开文件的方式（r:只读 w：只写  r+：读写）等.<br/>getmntent 参数：fp  	setmntent函数中返回的文件指针，即将要进行读写的文件指针。<br/> endmntent 参数：fp  函数setmntent打开的文件指针 |
| 返回值   | setmntent()：函数成功返回指向打开文件的文件指针FILE；失败返回NULL<br/>getmntent() 和 getmntent_r(): 在失败时返回指向mntent结构的指针或NULL， 成功返回struct mntent 结构体。<br/>endmntent()：始终返回1。 |





```c++
 struct mntent
 54   {
 55     char *mnt_fsname;       /* 挂载文件系统的名称  */
 56     char *mnt_dir;      /*文件系统路径前缀  */
 57     char *mnt_type;     /* 挂载的文件系统类型: ufs, nfs等  */
 58     char *mnt_opts;     /*挂载选项  */
 59     int mnt_freq;       /* 以天为单位的转存频率  */
 60     int mnt_passno;     /* 并行fsck上的传递数字  */
 61   };
```





## disk

```c++
#include <stdio.h>
#include <mntent.h>
#include <string.h>
#include <sys/vfs.h>
static const unsigned long long G = 1024*1024*1024ull;
static const unsigned long long M = 1024*1024;
static const unsigned long long K = 1024;
static char str[20];
char* kscale(unsigned long b, unsigned long bs)
{
	unsigned long long size = b * (unsigned long long)bs;
	if (size > G)
	{
		sprintf(str, "%0.2f GB", size/(G*1.0));
		return str;
	}
	else if (size > M)
	{
		sprintf(str, "%0.2f MB", size/(1.0*M));
		return str;
	}
	else if (size > K)
	{
		sprintf(str, "%0.2f K", size/(1.0*K));
		return str;
	}
	else
	{
		sprintf(str, "%0.2f B", size*1.0);
		return str;
	}
}
int main(int argc, char *argv[])
{
	FILE* mount_table;
	struct mntent *mount_entry;
	struct statfs s;
	unsigned long blocks_used;
	unsigned blocks_percent_used;
	const char *disp_units_hdr = NULL;
	mount_table = NULL;
	mount_table = setmntent("/etc/mtab", "r");
	if (!mount_table)
	{
		fprintf(stderr, "set mount entry error/n");
		return -1;
	}
	disp_units_hdr = "     Size";
	printf("Filesystem           %-15sUsed Available %s Mounted on/n",
			disp_units_hdr, "Use%");
	while (1) {
		const char *device;
		const char *mount_point;
		if (mount_table) {
			mount_entry = getmntent(mount_table);
			if (!mount_entry) {
				endmntent(mount_table);
				break;
			}
		} 
		else
			continue;
		device = mount_entry->mnt_fsname;//挂载文件系统的名称 
		mount_point = mount_entry->mnt_dir;///*文件系统路径前缀  */
		//fprintf(stderr, "mount info: device=%s mountpoint=%s/n", device, mount_point);
		if (statfs(mount_point, &s) != 0) 
		{
			fprintf(stderr, "statfs failed!/n");	
			continue;
		}
		if ((s.f_blocks > 0) || !mount_table ) 
		{
			blocks_used = s.f_blocks - s.f_bfree;
			blocks_percent_used = 0;
			if (blocks_used + s.f_bavail) 
			{
				blocks_percent_used = (blocks_used * 100ULL
						+ (blocks_used + s.f_bavail)/2
						) / (blocks_used + s.f_bavail);
			}
			
			if (strcmp(device, "rootfs") == 0)
				continue;
			if (printf("/n%-20s" + 1, device) > 20) printf("/n%-20s", "");
			char s1[20];
			char s2[20];
			char s3[20];
			strcpy(s1, kscale(s.f_blocks, s.f_bsize));
			strcpy(s2, kscale(s.f_blocks - s.f_bfree, s.f_bsize));
			strcpy(s3, kscale(s.f_bavail, s.f_bsize));
			printf(" %9s %9s %9s %3u%% %s/n",
					s1,
					s2,
					s3,
					blocks_percent_used, mount_point);
		}
	}
	return 0;
}
```



tatfs结构中可用空间块数有两种f_bfree和 f_bavail，前者是硬盘所有剩余空间，后

者为非root用户剩余空间，[ext3文件](https://www.baidu.com/s?wd=ext3%E6%96%87%E4%BB%B6&tn=24004469_oem_dg&rsv_dl=gh_pl_sl_csd)系统给root用户分有5%的独享空间，所以这里是不

同的地方。这里要强调的是每块的大小一般是4K（×这句话错误，不一定都是4k，正确做法是:总大小= sfs.f_blocks×f_bsize，即块数×每块的大小，单位是bytes，也就是要/1024/1024/1024才是GB单位，另外要注意的问题是sfs.f_blocks×f_bsize数据过大溢出，可以sfs.f_blocks/1024×f_bsize/1024=MB单位）。因此，要实现与df结果一致的就得在

获得块数上乘以4，这样已用、可用、总块数就可以实现。如果还要实现百分比一致，

那么要注意的是，df命令获得是整数百分比，没有小数，这里使用的进一法，而不是四

舍五入法。所以在程序里直接+1取整.

## mtab 与fstab的区别

/etc/mtab 记载的是现在系统已经装载的文件系统，包括操作系统建立的虚拟文件等，而/etc/fstab是系统准备装载的。每当 mount 挂载分区、umount 卸载分区，都会动态更新 mtab，mtab 总是保持着当前系统中已挂载的分区信息，fdisk、df 这类程序，必须要读取 mtab 文件，才能获得当前系统中的分区挂载情况a。





# 聊天室

## 发送文件

```c++
#include "head.h"
char *re_filename(char *filename);

void send_file(const char *filename, int sockfd) {
    printf("start send!\n");
    FILE *fp = NULL;
    size_t size;
    struct FileMsg filemsg;
    char *p;
    DBG(BLUE"filname is %s!\n"NONE, filename);
    if ((fp = fopen(filename, "rb")) == NULL) {//'b'以二进制打开
        perror("fopen");
        return ;
    }
    memset(&filemsg, 0, sizeof(filemsg));
    fseek(fp, 0L, SEEK_END);//将指针移到文件末尾
    filemsg.size = ftell(fp);//获取当前文件指针,得到文件的大小
    fseek(fp, 0L, SEEK_SET);//将指针移到文件起始位置
    strcpy(filemsg.name, (p = strrchr(filename, '/')) ? p + 1 : filename);// ./
    while((size = fread(filemsg.buff, 1, sizeof(filemsg.buff), fp))) {
        send(sockfd, (void *)&filemsg, sizeof(filemsg), 0);
        usleep(100);
        memset(filemsg.buff, 0, sizeof(filemsg.buff));
    }
    printf("end send!\n");
    return ;
}


```



## 接收文件

```c++
void recv_file(int sockfd) {
    printf("start recv!\n");
    size_t recv_size, total_size = 0, write_size = 0;
    long left_size;
    struct FileMsg packet_t, packet, packet_pre;
    int packet_size = sizeof(struct FileMsg);
    long offset = 0, cnt = 0, sum = 0;
    FILE *fp = NULL;
    char new_name[512];
    bzero(&packet, 0);
    bzero(&packet_pre, 0);
    bzero(&packet_t, 0);
    while(1) {
        if (offset) {
            memcpy(&packet, &packet_pre, offset);
        }
        while((recv_size = recv(sockfd, (void *)&packet_t, packet_size, 0)) > 0) {
            DBG(RED"packet_t.size : %ld!\n"NONE, packet_t.size); 
            if (!sum) left_size = packet_t.size;
            sum++;
            left_size -= sizeof(packet_t.buff);
            DBG(GREEN" recv_size : %ld, buff_size : %ld, left size is %ld!\n"NONE,
                recv_size, sizeof(packet_t.buff), left_size);
            
            if (recv_size + offset == packet_size) {
                memcpy((char *)&packet + offset, &packet_t, recv_size);
                offset = 0;
                DBG(L_GREEN"整包!\n"NONE);
                break;
            } else if (recv_size + offset < packet_size) {
                memcpy((char *)&packet + offset, &packet_t, recv_size);
                offset += recv_size;
                DBG(BLUE"拆包!, size : %ld\n"NONE, packet_t.size);
                //if (left_size <= 0) break;
                continue;
            } else {
                int need = packet_size - offset;
                memcpy((char *)&packet + offset, &packet_t, need);
                offset = recv_size - need;
                memcpy((char *)&packet_pre, (char *)&packet_t + need, offset);
                DBG(RED"粘包!\n"NONE);
                break;
            }
        }

        /*if (!cnt) {
            DBG(BLUE"Start recv file %s, with size %ld!\n"NONE, packet.name, packet.size);
            char name[1024] = {0};
            sprintf(name, "./data/%s", packet.name);
            if ((fp = fopen(name, "wb")) == NULL) {
                perror("fopen()");
                return ;
            }
        }*/
        

        DBG(RED"offset : %ld!\n"NONE,offset);
        if (!cnt) {
            char path[30];
            sprintf(new_name, "%s", re_filename(packet.name));
            sprintf(path, "./data/%s", new_name);
            DBG(GREEN"create file!, file name is %s\n"NONE, new_name);
            if ((fp = fopen(path, "wb")) == NULL) {
                perror("fopen file failed");
                return ;
            } 
        }
        cnt += 1;
        if (packet.size - total_size >= sizeof(packet.buff)) {
            write_size = fwrite(packet.buff, 1, sizeof(packet.buff), fp);
            DBG(BLUE"write a packet to %s!\n"NONE, new_name);
        } else {
            write_size  = fwrite(packet.buff, 1, packet.size - total_size, fp);
            DBG(YELLOW"write helf packet to %s!\n"NONE, new_name);
        }
        
        total_size += write_size;
        memset(packet_t.buff, 0, sizeof(packet.buff));
        DBG(RED"total_size : %ld!\n\n"NONE, total_size);
        if (total_size >= packet.size) {
            DBG(RED"recv finish!"NONE);
            break;
        }
    }
    //if (offset) {
    //    DBG(RED"have offset!\n"NONE);
  //  }
    printf("have finish send!\n");
    fclose(fp);
    return ;
}

char *re_filename(char *filename) {
    FILE *fp;
	char *tmp = (char *)malloc(sizeof(char) * 512);
    char *f_name = (char *)malloc(sizeof(char) * 512);
    char *b_name = (char *)malloc(sizeof(char) * 512);
    char path[30];
    sprintf(path, "./data/%s", filename);
    fp = fopen(path,"r");
    if (fp != NULL) {
        int ans = 1;
        int i = strlen(filename) - 1;
        for (; i >= 0; i--) {
            if (filename[i] == '.') break;
        }
        strncpy(f_name, filename, i);
        strncpy(b_name, filename + i, strlen(filename) - i);
        while(1) {
            DBG(RED"create %s is failed!\n"NONE, filename);
            sprintf(tmp, "./data/%s%d%s", f_name, ans, b_name);
            if ((fp = fopen(tmp, "r")) == NULL) {
                memset(filename, 0, sizeof(filename));
                sprintf(filename, "%s%d%s", f_name, ans, b_name);
                break;                 
            }
            memset(tmp, 0, sizeof(tmp));
            ans += 1;       
        }     
    }
    free(tmp);
    free(f_name);
    free(b_name);
    return filename;
}

```





#足球小游戏

 









# 题

## 判断题

| 判断题                                          |      |
| ----------------------------------------------- | ---- |
| 1.Linux操作系统是一种典型的多用户多任务操作系统 | true |
|                                                 |      |
|                                                 |      |
|                                                 |      |

|                                                              |                                                              |
| :----------------------------------------------------------- | ------------------------------------------------------------ |
| 1. POSIX互斥锁相关函数有                                     | int pthread_mutex_destroy(pthread_mutex_t * mutex)<br/>  int pthread_mutex_lock(pthread_mutex_t * mutex)<br/>  int pthread_mutex_trylock(pthread_mutex_t *mutex); //加锁, 失败不阻塞<br/>  int pthread_mutex_unlock(pthread_mutex_t * mutex)<br/>  int pthread_mutexattr_init(pthread_mutex_t *mutex);<br/> |
| 2. Linux程序运行后，文件句柄0，1，2, 3, 4分别是              | 0标准输入 1标准输出 2标准错误 3标准辅助 4标准列表            |
| 3. 权限rwx --- ---                                           | chmod +_ _ _ (r: 4 , w : 2 : x : 1)                          |
| 4. Linux进程中，应用的运行起始地址是一样的, 是如何做到的     | 使用虚拟内存转换                                             |
| 5. 在页式存储管理方案中，进行主存分配的单位是                | 块                                                           |
| 6. 在UNIX系统中创建新进程，需要调用系统函数                  | fork()                                                       |
| 7. 带符号数-86在微机中所表示的二进制数值是                   | 10101010B                                                    |
| 8. 操作系统中同时存在者多个进程，它们（   ）。               | 可以共享允许共享的系统资源                                   |
| 9. 一个用户的作业从开始进入系统到结束在计算机系统中经过的阶段为 | 提交、后备、运行、完成                                       |
|                                                              |                                                              |
|                                                              |                                                              |
|                                                              |                                                              |
|                                                              |                                                              |
|                                                              |                                                              |
|                                                              |                                                              |
|                                                              |                                                              |
|                                                              |                                                              |
|                                                              |                                                              |
|                                                              |                                                              |
|                                                              |                                                              |
|                                                              |                                                              |
|                                                              |                                                              |
|                                                              |                                                              |
|                                                              |                                                              |
|                                                              |                                                              |
|                                                              |                                                              |
|                                                              |                                                              |
|                                                              |                                                              |
|                                                              |                                                              |
|                                                              |                                                              |
|                                                              |                                                              |
|                                                              |                                                              |
|                                                              |                                                              |
|                                                              |                                                              |
|                                                              |                                                              |
|                                                              |                                                              |
|                                                              |                                                              |
|                                                              |                                                              |
|                                                              |                                                              |
|                                                              |                                                              |
|                                                              |                                                              |
|                                                              |                                                              |
|                                                              |                                                              |
|                                                              |                                                              |
|                                                              |                                                              |
|                                                              |                                                              |
|                                                              |                                                              |
|                                                              |                                                              |
|                                                              |                                                              |

