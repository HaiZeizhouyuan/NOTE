



# 层

端到端(房间 对房间)



运输层协议概述

TCP :  传输控制协议面向链接, 可靠的数据传输协议

UDP: 用户数据协议无连接, 不可靠的数据传输协议(可校验, 可交付)

IP: 尽力而为交付服务\



多路复用与多路分解

源端口号



## 为什么会选择无连接传输:UDP(对时间敏感)

1.关于何时,发送什么数据的应用层控制更为精细

2.无需建立链接

3.无状态链接

4.分组开销小



UDP报文段结构

校验和



# 计算机网络

# １．请你说一下TCP怎么保证可靠性, 并且简述TCP建立链接和断开链接的过程

### TCP保证可靠性：

（１）序列号，确认回答，超时重传

　　数据到达接收方，　接收方需要发出一个确认应答，　表示已经收到该数据段，并且 $\color{red}{确认序号}$ 会说明 它下一次需要接受的$\color{blue}{数据序列号}$．　如果发送方迟迟未收到$\color{red}{确认应答}$，　那么可能是发送的数据丢失，　也可能是确认应答丢失，这时发送方在等待一段时间后会$\color{red}{重新传输}$．这个时间一般是$\color{blue}{２*RTT(报文段往返时间) +一个偏差值}$．

 （２）窗口控制与高速重发控制/快速重传（重复确认应答）

　　TCP会利用$\color{red}{窗口控制}$来提高传输速度，　意思是在一个窗口大小内，　不用一定要要等到应答才能发送下一段数据，　$\color{blue}{窗口大小}$就是无需等待确认而可以继续发送数据的最大值．$\color{red}{如果}$不使用窗口控制，　每一个没收到确认应答的数据都需要重发．

　　使用窗口控制，　如果数据段１００１～２０００丢失，　后面数据每次传输，　接收端都会不停地发送序号为１００１的应答，　表示我要接受１００１开始的数据，　发送端如果收到３次相同的应答，　就会立刻进行重发；但还有种情况有可能是数据收到了，　但是有的确认应答丢失时了，　这种情况不会进行重发，　因为发送端知道，如果是数据丢失，　接受端不会放过它，　会疯狂向它提醒．．．．．

（３）拥塞控制

​	如果把窗口定的很大，　发送端连续发送大量的数据，　可能会造成网络的拥塞，　甚至造成网络的瘫痪．所以TCP在为了防止这种情况而进行了$\color{red}{拥塞控制}$．

​	慢启动  : 定义拥塞窗口，一开始将该窗口大小设置为１，　之后每次收到确认应答（经过一个rit），　将拥塞窗口大小 *２；

 	拥塞控制：设置慢启动的阈值，　一般开始设置为65536．$\color{red}{拥塞避免}$是指当拥塞窗口大小达到这个阈值，　拥塞窗口的大小不在指数上升，　而是加法增加（每次确认应答/每个rit，　拥塞窗口大小＋１），　以此来避免拥塞.

​	将报文段的超时重传看做拥塞，　则一但发生超时重传，我们先将阈值大小设为当前窗口大小的一半，　并将窗口大小设为初始值１，　然后重新进入慢启动过程．

 	快速重传:在遇见3次重复确认应答(高速重发控制)时, 代表收到了3个报文段,但是这之前的一个段丢失了, 便对它进行立即重传.

​	然后, 先将阈值设为当前窗口大小的一半, 然后将拥塞窗口大小设为慢启动阈值+3的大小

​	这样就可以达到:在TCP通信时,网络吞吐量呈现逐渐的上升, 并且随着拥塞阻塞来降低吞吐量, 再进入慢慢上升的过程, 网络不会轻易的发生瘫痪.

# 2.请说一说TCP拥塞控制, 以及达到什么情况烦人时候开始减慢增长的速度?

P 132

(2) 

采用**拥塞避免算法**和**慢开始**的时候:

一旦cwnd>慢开始门限,就开始采用拥塞避免算法, 减慢开始速度.

一旦出现丢包的情况, 就重新进行慢开始, 减慢增长速度.

采用**快恢复**和**快速重传算法**的时候:

一旦发送方连续收到三个重复确认时,就开始采用快重传算法, 减缓增长速度.



# 3.TCP建立连接和断开连接的过程(三次握手和四次挥手), 及原因, 为什么不两次握手, 或四次握手?

​	三次握手:

​	C->SYN(seq=c) ->S

​	S->SYN+ACK(seq=s, ack=c+1)->C

​	C->ACK(seq=c+1, ack=s+1)->S



​	 1.Client将标志位$\color{red}{SYN}$置为1, 随机产生一个值$\color{red}{seq = J}$, 并将该数据包发给Server, Client进入SYN_SENT状态, 等待Server 确认.

 	2.Server收到数据包后有标志位SYN=1 知道Client  请求建立连接, Server 将标志位$\color{red}{SYN和ACK}$都置为1,         $\color{red}{ack = J + 1}$, 随机产生一个值$\color{red}{seq = K}$, 并将该数据包发送给Client以确认连接请求, Server进入SYN_RCVD状态.

​	3.Client收到确认后, 检查$\color{red}{ack}$是否为J + 1, $\color{red}{ACK}$是否为1, 如果正确则将标志位$\color{red}{ACK}$置为1, $\color{red}{ack=K+1}$, 并将该数据包发送给Server, Server检查$\color{red}{ack}$是否为K + 1, $\color{red}{ACK}$是否为1,如果正确则连接建立成功, Client和Server进入ESTABLISHED状态, 完成三次握手, 随后 Client与Server 之间可以开始传递数据了.

​	

​	三次握手的原因： 三次握手可以防止已经失效的连接请求报文突然又重新传输到服务器导致的服务器的资源的浪费．

​	二次不可以:tcp  是全双工通信, 两次握手只能确定单向链路是可以通信的,并不能保证反向的通信正常

​	不用四次:本来握手应该和挥手一样都是需要确认两个方向都能联通的, 本来模型应该是:

1.客户端发送syn0给服务器

2.服务器收到syn0, 回复ack(syn0+1)

3.服务器发送syn1

4.客户端收到syn1, 回复ack(syn1+1)

因为tcp是全双工的, 上边的四部确认了数据在两个方向上都是可以正确到达的, 但是2, 3步没有上下的联系, 可以将其合并,加快握手的效率, 所以就变成了3步握手.

四次挥手:

C->FIN->S

S->ACK->C

S->FIN->C

C->ACK->S  

​	由于TCP连接时全双工的, 因此, 每个方向都必须要单独进行关闭,这一原则是当一方完成数据发送任务后, 发送一个FIN来终止这一方向的连接, 收到一个FIN只是意味着这一方向没有数据流动了, 即不会在收到数据了但是在这个TCP连接上仍然能够发送数据，　直到这一方向也发送了FIN．首先进行关闭的一方将执行主动关闭，　而另一方则执行被动关闭．

​	１．数据传输结束后，客户端的应用进程发出连接释放报文段，　并停止发送数据，客户端进入FIN_WAIT_1状态，　此时客户端任然可以接收服务器发送来的数据．

​	２．服务器接收到FIN后，　发送一个ACK给客户端，　确认序号为收到的序号＋１，服务器进入CLOSE_WAIT状态，．客户端收到后进入FIN_WAIT_2状态．

​	３．当服务器没有数据要发送时，　服务器发送一个FIN 报文，　此时服务器进入LAST_ACK状态，等待客户端的确认．

​	４．客户端收到服务器的FIN 报文后，　给服务器发送一个ACK报文，　确认序列号为收到的序列号＋１，．此时客户端进入TIME_WAIT状态，　等待2MSL.（MSL：报文段组＝最大生存时间），　然后关闭连接．

​	四次挥手的原因：由于连接的关闭控制权在应用层，　所以被动关闭的一方在接收到FIN包时，TCP协议栈会自动发送一个ACK确认包，　优先关闭一端的通信．然后通知应用层，由应用层决定什么时候发送FIN包．应用层可以使用系统调用函数read = 0来判断对端是否关闭连接．



# 4.请回答一下HTTP和HTTPS的区别，以及HTTPS有什么优缺点？

HTTP协议和HTTPS协议区别如下：（安全性，　握手，证书，　端口）

​	（１）HTTP协议是以明文的方式在网络中传输数据，而HTTPS协议传输的数据则是经过TLS 加密后的，　HTTPS具有更高的$\color{red}{安全性}$；

​	（２）HTTPS在TCP三次握手阶段之后，还需要进行SSL的handshake, 协商加密使用的$\color{red}{对称加密密钥}$．

​	（３）HTTPS协议需要服务端申请$\color{red}{证书}$，浏览器端安装对应的$\color{red}{根证书}$

​	（４）HTTP协议的$\color{red}{端口}$是80，　浏览器协议的端口是443

HTTPS优点：（安全, 准确）

HTTPS传输数据过程中使密钥进行**加密**，　所以安全性更高

HTPPs协议可以**认证**用户和服务器，　确保数据发送到正确的用户和服务器

HTTPS的缺点：（成本高，　延时长）

​           HTTPS握手阶段延时较高，　由于在进行HTTP会话之前还需进行SSL**握**手，　因此HTTPS协议握手阶段延时增加．

​	 HTTPS部署成本高，　一方面HTTPS协议需要**证书**来验证自身的安全性，　所以需要购买CA证书；另一方面由于采用HTTPS协议需要进行加密解密的**计算**，　占用的CPU资源较多，　需要的服务器配置或数目高．

# 5.　请你说一下HTTP返回码

HTTP协议的响应报文由状态行，响应头部和响应包体组成，　其响应状态码总体描述如下：

１xx :指示信息－－表示请求已接收，　继续处理．

2xx：成功－－表示请求已被成功接收，　理解，　接受．

3xx：重定向－－要完成请求必须进行更进一步的操作　

4xx:　客户端错误－－请求有语法错误或请求无法实现

5xx：服务器端错误－－服务器未能实现合法的请求．

常见状态代码，状态描述的详细说明如下：

200　OK:　客户端请求成功．

206 　partial content : 服务器已经正确处理部分GET 请求，实现$\color{red}{断点续传}$或$\color{red}{同时分片下载}$，　该请求必须包含Range请求头来指示客户端期望得到的范围． 

300　multiple choices(可选重定向)：被请求的资源有一系列可供选择的反馈信息，　由浏览器/用户自行选择其中一种．

301 moved permanently(永久重定向)：该资源已被永久移动到新位置, 将来任何对该资源的访问都要使用本响应的若干个URI之一.

302 move temporarilty(临时重定向): 请求的资源现在临时从不同的 URI中获得.

304  not modified: 如果客户端发送一个待条件的GET 请求并且该请求已经被允许, 而文档内容未被改变,则返回304, 该响应不包含包体(即可直接使用缓存).

403 Forbidden: 服务器收到请求, 但拒绝提供服务

t Found: 请求的资源不存在, 举个例子: 输入 了错误的URL.

# 6.请你说一下IP地址作用,以及MAC地址作用

​	MAC地址是一个$\color{red}{硬件地址}$, 用来定义$\color{red}{网络设备}$的位置, 主要由数据链路层负责.而IP地址是IP协议提供的一统一的地址格式, 为互联网的每一个网络和每一台主机分配一个逻辑地址;以此来屏蔽物理地址的差异.

# 7.请你介绍一下操作系统中的中断

​	中断是指CPU对系统发生的某个事件做出的一种反应, CPU暂停正在执行的程序,保存现场后自动去执行相应的处理程序 , 处理完该事件后在返回中断处理处继续执行原来的程序.中断一般三类，　一种是由CPU外部引起的，　如I/O中断.时钟中断，　一种是来自CPU内部事件或程序执行中引起中断，　列如程序非法操作，　地址越界，浮点溢出），最后一种是在程序中使用了系统调用引起的，　而中断处理一般范围中断响应和中断处理两个步骤，中断响应由硬件实施．中断处理主要由软件实施．\\

# 8.输入url地址按下回车发生了什么？

**1.输入url地址后，首先进行DNS解析，将相应的域名解析为IP地址；**

**2.客户端根据IP地址去寻找相应的服务器**;

**3.与服务器进行TCP的三次握手；**

**4.客户端找到相应的资源库；**

**5.根据资源库返回页面信息；**

 **6.浏览器根据自身的执行机制解析页面；（浏览器的执行机制？重绘？重排？......）**

　　浏览器解析页面时，会找到每一个文件夹（css、js、html、img......），每一个文件夹下的资源会重新走到第二步，去找到相应的服务器，然后一步步执行。

**7.最后服务器将解析信息返回给客户端，进行TCP的四次挥手，断开连接**

**8.至此，客户端显示自己请求，即服务端返回的东西**

# 9.请回答OSI七层模型和TCP/IP四层模型，　每层列举两个协议

七层：

物理层：通过媒介传输比特，　确定机械及电气规范，　传输单位为bit，主要包括的协议为：IEE802.3 , CLOCK , RJ45

数据链路层：将比特组装成帧和点到点的传递，　传输单位为帧，　主要包括的协议为MAC , VLAN ,PPP

网络层：负责数据包从源到宿的传递和网际互联，　传输单位为包．IP , ARP---, ICMP

传输层：提供端到端的可靠报文传递和错误恢复，　传输单位为报文，TCP, UDP

会话层：建立.管理, 和终止会话, 传输单位为SPDU,主要包括协议 为RPC, NFS

表示层：对数据进行翻译,加密和压缩,主要协议包括JPEG, ASII

应用层：允许访问OSI环境的手段, 传输单位为APDU, 主要协议为FTP, HTTP, DNS

四层:

网络连接层：MAC, VLAN

网络层:IP, ARP,ICMP

传输层:TCP, UDP

应用层:HTTP,DNS, SMTP

# 10．搜索baidu，　会用到计算机网络中的什么层？每层是干什么的．



浏览器输入URL

**浏览器要将URL解析为IP地址**，解析域名就需要用到DNS协议(应用层)，　首先主机会查询DNS的缓存，　如果没有就给本地DNS 发送查询请求．DNS的查询分为两种方式，　一种是递归查询，一种是迭代查询．如果是迭代查询，本地的DNS服务器,向根域名服务器发送查询请求，根域名服务器告知该域名的一级域名服务器，　然后本地域名服务器给该一级域名服务器发送查询请求，　然后依次类推直到查询到该域名的IP 地址．DNS服务器是基于UDP的，因此会用到UDP协议（传输层）．

**得到IP地址后，浏览器就要与服务器建立一个http连接．**因此就要用到http协议．http生成一个get 请求报文，　将该报文传给TCP层(传输层)处理，所以还会用到TCP协议．如果采用https还会使用https协议先对http数据包进行加密．TCP 层如果有需要先将HTTP数据包分片，分片依据路径MTU和MSS．TCP的数据包然后会发送给IP层(网络层)，用到IP协议．IP层通过路由选路，　一跳一跳发送到目的地址．当然在一个网段内的寻址是通过以太网协议实现的，　以太网协议需要直到目的IP地址的物理地址，又需要ARP协议(网络层)．



其中:

1. DNS协议,http协议,https协议属于应用层

应用层是体系结构中的最高层,应用层确定进程之间通信的性质以及满足用户的需要.

2.TCP/UDP属于传输层

传输层的任务是负责主机两个进程之间的通信.

3.IP协议,ARP协议属于网络层

网络层负责为分组交换网上的不同主机提供通信.网络层的另一个任务就是要选择合适的路由, 使源主机运输层所传下来的分组能够交付到目的主机.

4.数据链路层:

当发送数据时, 数据链路层的任务就是将在网络层交下来的IP数据报组装成帧, 在两个相邻结点间的链路上传送以帧为单位的数据.

5.物理层的任务就是透明地传送比特流.

# 9.socket开发的网络层操作?

C: socket->connect;

S:socket->bind->listen->accept;

# 10.请你说一说传递IP层怎么知道报文该给哪个应用程序, 他怎么区分UDP报文还是TCP报文?

根据端口区分:

看ip头中的协议标识字段,17是udp, 6是tcp

# 11.情你说一说TCP/IP数据链路层的交互过程(P134)

# 12.请问server 端监听端口,但还没有客户端连接进来,此时进程处于什么状态?

使用accept则处于堵塞状态;

使用了epoll, select等这样的io复用状况下,处于运行状态;

# 13.





# 